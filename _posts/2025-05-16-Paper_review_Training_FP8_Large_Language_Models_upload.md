---
layout: single
title:  "[논문 리뷰] Training FP8 Large Language Models"
categories: "AI"
tag: "review"
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 논문 리뷰
오늘부터 명작 논문들을 리뷰해 볼까 한다.  
AI 기본을 이해하기 위한 근본 논문부터, 최신 AI 기술 동향을 담은 논문까지, 다양하게 리뷰해 보자.  
처음 해 보는거기도 하니까, 초심자도 이해할 수 있을 정도로 엄청 풀어서 적어보겠다.  

FP8-LM: Training FP8 Large Language Models  
논문 링크 : [https://arxiv.org/abs/2310.18313](https://arxiv.org/abs/2310.18313)  

이 논문은, 대규모 언어 모델인 ChatGPT나 Llama 같은 모델을 훈련시킬 때, FP8이라는 매우 작은 숫자 형식을 사용해서 컴퓨터가 더 작은 메모리와 빠른 속도로 모델을 훈련할 수 있는 방법을 제안한다.  


대규모 언어모델은 사람의 뇌처럼 수십억 개의 파라미터를 가진 AI이다.  
사람의 뇌가 많은 뉴런의 결합으로 이루어진 것처럼, 많은 양의 파라미터를 가진 AI 모델은 문장을 이해하고 생성하는데 뛰어난 능력을 보여준다.  
하지만, 파라미터에는 가중치 값이 있고, 연산이 이루어 지기 때문에, 이런 거대한 모델을 훈련하는 데는 엄청난 컴퓨터 자원이 필요하다.  
엄청난 양의 메모리와 몇 주, 몇 달의 시간, 많은 파라미터 계산을 효율적으로 처리하기 위한 높은 성능의 GPU 수천 대가 필요하다.  
따라서, 많은 사람들이 더 작은 자원으로 더 빠르게 AI를 훈련할 방법을 연구하곤 하는데, 이 논문은 그 해결책으로 가중치와 계산된 값이 저장되는 형식인 부동소수점 중 하나인 FP8을 이용하는 방법을 제안한다.  
FP8은 파라미터값을 계산할 때 사용되는 데이터 형식이다.  
FP는 대표적으로 32, 16, 8이 있는데 이는 각각 32비트, 16비트, 8비트로, 비트 수가 작을수록 속도가 빠르지만, 정확도가 낮고, 비트 수가 높을수록 속도가 느리지만 정확도가 높아진다.  
FP8은 높은 속도를 제공하지만, 정확도가 지나치게 낮아 아주 작은 값, 아주 큰 값들이 제대로 저장되지 않기 때문에 모델이 학습 중에 오류를 일으키는 일이 너무 많다.  
따라서, 이 높은 오류율을 해결하는 것이 FP8의 핵심이라고 할 수 있다.  이 논문에서는 이런 오차를 다음과 같은 방법을 통해서 해결한다.  


1. FP8 그래디언트와 통신  
그래디언트는, 모델이 학습할 때, 어느 방향으로 가중치를 조절해야 오류를 줄일 수 있을지 알려주는 값이다.  
이 값을 여러 GPU가 주고받아 합쳐야 한다.  
기존의 방법은 FP32, FP16을 사용하면, 속도도 느리고, 메모리 대역폭을 많이 잡아먹는다.  
하지만, 이를 FP8로 바꾸면 데이터의 크기가 25%로 줄어들지만, 작은 값이 사라지는 언더플로우나, 큰 값이 오류를 일으키는 오버플로우가 발생할 수 있다.  
이런 오류를 자동 스케일링을 통해 해결한다. 그래디언트 값을 FP8 범위에 맞게 조정하여, 값이 너무 크면 나누고, 너무 작으면 곱해서 FP8으로 표현할 수 있는 범위로 만드는 것이다.  
여러 GPU간 통신 시, 모든 GPU가 동일한 범위를 공유해 효율적으로 데이터를 합칠 수 있다.  
이를 통해 통신 데이터량 63%~65% 감소하였으며, 이에따른 메모리 사용량도 줄었다.  


2. FP8 옵티나이저  
옵티나이저는, 모델이 그래디언트를 바탕으로 가중치를 업데이트하는 알고리즘으로, 대표적으로 Adam 옵티나이저 등이 있다.  
옵티나이저는, 마스터 가중치(모델의 핵심값), 그래디언트, 1차 모멘트(그래디언트의 이동평균), 2차 모멘트(그래디언트의 제곱 평균)을 저장한다.  
기존에는 이 모든 값을 FP32로 저장해 파라미터당 16바이트 메모리가 필요하여, 대규모 모델에서는 메모리가 엄청나게 들어간다.  
이를 정밀도 분리를 통해 해결했는데, 이는 각각의 요소에 적용되는 부동소수점을 다르게 하여 메모리를 절약하는 방식이다.  
마스터 가중치는 작은 값이 많으므로 FP16(2바이트)으로, 1차 모멘트는 FP8(1바이트), 2차 모멘트는 언더플로우가 생기기 쉬우므로 FP16(2바이트)으로 저장한다.  
이렇게 하면, 메모리 사용량이 파라미터당 16바이트에서 6바이트로, 2.6배 감소한다.  

3. FP8 분산 병렬 학습  
대규모 모델은 한 대의 GPU로 훈련할 수 없어 여러 GPU를 사용하는데, FP8을 병렬처리에 바로 적용하면 스케일링 팩터(값 크기 조정 정보)를 관리하기 힘든 문제가 있다.  
이를 해결하기 위해, FP8으로 중간값을 처리하여 통신 비용을 34% 감소시켰고, 메모리 차지가 많은 문자들을 분리하지 않고, 크기가 큰 문장 순서대로 GPU에 집어넣어 균형을 유지, 더 긴 문장도 처리할 수 있게 한다.  
이에 따라 메모리 최대 사용량이 최대 39%감소 하였으며, 더 긴 문장을 처리할 수 있게 되었다.  


앞선 3가지 방법을 적용해 딥러닝 시킨 FP8 모델은 더 많은 자원을 소모하는 FP16과 동등한 성능을 발휘하는 모델 성능을 보여주었다.  
질문 답변, 문장 완성 등 다양한 태스크에서 FP8 모델이 FP16 모델과 비슷한 정확도를 보여주었으며, 사람의 피드백으로 모델을 정교화하는 과정에서도, FP8이 FP16과 동등한 성능을 유지한 채로 가중치 32%, 옵티나이저 상태 62% 감소라는 효과를 보였다.  
또한, 학습률 같은 초기 딥러닝 설정을 수정하지 않고 기존에서 FP8로만 바꾸는 것으로 쉽게 적용이 가능하다.  
대규모 모델 훈련 비용을 획기적으로 줄여 더 쉽게 AI를 개발할 수 있게 한다.  
메모리, 시간 자원을 더 적게 사용하므로 에너지 소비와 탄소 배출을 줄일 수 있다.  
무엇보다, 오픈소스이므로 누구나 사용할 수 있는 것이 제일 큰 장점이다.  