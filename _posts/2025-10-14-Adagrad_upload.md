---
layout: single
title:  "Adagrad"
categories: "AI"
tag: "linear algebra"
toc: true
author_profile: false
sidebar:
    nav: "docs"
---


## Adaptive Gradient  

기존의 경사하강법이나, 모멘텀은 모두 모든 파라미터의 동일한 학습률을 적용한다.  
하지만, 그 수 많은 파라미터들이 모두 똑같이 중요하거나, 같은 횟수로 사용되지 않는다.  

- 희소한 데이터(Sparse Data): 자연어 처리에서 어떤 단어는 매우 자주 등장하지만, 어떤 단어는 아주 가끔 등장한다.  자주 등장하는 단어의 파라미터는 자주 업데이트 되지만, 가끔 등장하는 단어의 파라미터는 학습 기회가 적다.  
- 특성마다 다른 중요도: 어떤 파라미터는 이미 최적값에 가까워져서 미세 조정이 필요한 반면, 어떤 파라미터는 아직 최적값에서 멀리 떨어져 있어 더 큰 폭으로 움직여야 할 수 있다.  

이런 상황에서 모든 파라미터에 같은 크기의 학습률을 적용하는 것은 비효율적이며, 이걸 해결하기 위한것이 Adagrad 이다.  

Adagrad는 지금까지 많이 변화(업데이트)한 파라미터는 학습률을 작게 만들고, 변화가 거의 없었던 파라미터는 학습률을 크게 만드는 것으로 해결한다.  

 - 변화가 많은 파라미터: 이미 많이 움직였다는 것은 최적값에 근접했을 가능성이 높다고 보고, 조금씩 움직이며 세밀하게 탐색하도록 학습률을 줄인다.  
 - 변화가 적었던 파라미터: 아직 충분히 학습되지 않았다고 보고, 더 과감하게 움직여 빠르게 최적값을 찾아가도록 학습률을 키운다.  

이렇게 각 파라미터가 걸어온 길을 기억하고, 그에 맞춰 보폭(학습률)을 자동으로 조절해주는 것이다.  

## 1. 기울기 제곱 누적 (Weight Update)  

$$G_t = G_{t-1} + (\nabla_W L(W))^2$$  

과거의 모든 기울기 정보를 축적하는 과정이다.  
 - $G_t$: 현재 시점($t$)까지의 기울기 제곱값들의 총합이다. 각 파라미터 별로 따로 계산된다.  
 - $G_{t-1}$: 이전 시점($t-1$)까지의 기울기 제곱값들의 합 이다.  
 - $(\nabla_W L(W))^2$: 현재 시점의 기울기(Gradient)를 **제곱**한 값이다. 제곱을 하는 이유는 변화의 방향(+,-)과 상관없이 '변화의 크기' 자체에만 집중하기 위함이다.  

파라미터가 많이 업데이트되었다면, 그동안의 기울기 값들이 컸을 것이고, 이 값들의 제곱이 계속 더해져 $G_t$는 매우 커질 것이다.  
반대로 변화가 거의 없었다면 $G_t$는 작은 값을 유지한다.  


## 2. 가중치 업데이트 (Weight Update)  

$$W \leftarrow W - \frac{\eta}{\sqrt{G_t + \epsilon}} \nabla_W L(W)$$  

여기에서 적응형 학습율이 적용된다.  
 - $W$: 업데이트할 가중치(파라미터)이다.  
 - $\eta$: 사용자가 초기에 설정하는 전역 학습률(Global Learning Rate)이다. 이제는 기준점 역할만 한다.  
 - $\sqrt{G_t + \epsilon}$: 이 부분이 각 파라미터의 고유한 학습률을 조절하는 역할을 한다.  
    * $G_t$: 위에서 계산한 과거 기울기 제곱의 총합이다.
    * $\epsilon$: 분모가 0이 되는 것을 방지하기 위한 아주 작은 값이다 (e.g., `1e-8`).
 - $\nabla_W L(W)$: 현재 시점의 기울기 이다.  
실제 파라미터에 적용되는 유효 학습률(Effective Learning Rate)은 $\frac{\eta}{\sqrt{G_t + \epsilon}}$이다.  
만약 과거에 많이 변했다면 ($G_t$가 크다면), 분모가 커져서 유효 학습률은 작아진다.  
만약 과거에 변화가 적었다면 ($G_t$가 작다면), 분모가 작아서 유효 학습률은 커진다.  

## 문제점
이거 다 좋은데, 학습이 길어질 수록 학습률이 계속해서 줄어든다는게 제일 큰 문제점이다.  
$G_t$는 기울기 '제곱' 값을 계속 더해가기 때문에 시간이 지날수록 무조건 커지기만한다.  
이로 인해 분모가 무한히 커지게 되고, 결국 학습률이 0에 수렴하여 어느 순간 모델이 더 이상 학습하지 않게 된다.  

## 결론
이거랑 모멘텀이랑 합쳐져서 아담이 만들어 진다.  
혀튼 이 모든건 아담을 올바르게 이해하기 위함이므로,  
이거로 알아두고 자면 좋다.  