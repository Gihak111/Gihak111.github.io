---
layout: single
title: "AI 입문 10편: 트랜스포머 변형, Fine-Tuning, ONNX)"
categories: "AI"
tag: "Explanation"
toc: true
author_profile: false
sidebar:
nav: "docs"
---

### AI 입문 10편: 트랜스포머 변형, Fine-Tuning, 그리고 ONNX 배포

AI 입문 시리즈의 이전 9편에서는 트랜스포머 최적화 기법으로 Adam/AdamW, 학습률 스케줄링, Flash Attention, 그리고 친칠라 법칙(Chinchilla Law)을 다루었다.  
이번 10편은 시리즈의 마지막 편으로서, 트랜스포머 아키텍처의 변형, 미세조정(Fine-Tuning) 기법, 그리고 최종 배포(Deployment) 과정을 상세하게 설명한다.  

---

### 0. 이 글의 핵심 내용


* 트랜스포머 변형: Vision Transformer(ViT)가 이미지를 여러 패치(Patch)로 분할하여 기존 텍스트 기반의 어텐션 메커니즘을 시각적으로 어떻게 적용하는지 분석한다. 또한, Multimodal Transformer가 텍스트, 이미지, 오디오 등 서로 다른 형태의 데이터를 어떻게 통합하여 처리하는지 원리를 다룬다.  
* 미세조정(Fine-Tuning): 사전 학습된 대규모 트랜스포머 모델을 특정 과업(Task)에 효율적으로 적응시키기 위한 기법인 LoRA(Low-Rank Adaptation)와 PEFT(Parameter-Efficient Fine-Tuning)를 소개한다.  
* 배포(Deployment): 학습이 완료된 모델을 ONNX(Open Neural Network Exchange) 표준 형식으로 변환하여 CPU, GPU, 모바일 등 다양한 하드웨어 환경에서 효율적으로 추론을 수행하는 과정을 설명한다.  
* 수식과 미분: 각 단계의 수학적 원리를 이해하기 위해 ViT의 패치 임베딩 과정에 대한 미분, 크로스 어텐션(Cross-Attention)의 기울기 계산, LoRA의 업데이트 방식, 그리고 ONNX 변환 후 검증 과정을 수식과 함께 분석한다.  
* 적분 관점: 모델의 학습 과정을 연속적인 변화의 누적으로, 배포 과정을 최적화 결과의 집약으로 바라보는 통합적인 시각을 제시한다.  

---

### 1. 트랜스포머 변형의 배경: 텍스트에서 비전으로의 확장

#### 1.1 변형의 필요성

트랜스포머는 본래 자연어 처리(NLP)를 위해 설계된 모델이었으나, 그 구조적 잠재력으로 인해 컴퓨터 비전(CV) 및 멀티모달 과업으로 그 적용 범위가 확장된다.  
기존의 컨볼루션 신경망(CNN)이 이미지의 지역적 특징(Local Feature)을 추출하는 데 집중하는 반면, 트랜스포머의 어텐션 메커니즘은 데이터 전체의 전역적 의존성(Global Dependency)을 학습하는 데 강점을 가진다.  

이러한 특성을 활용하여 Vision Transformer(ViT)는 이미지를 여러 개의 작은 패치로 분할하고, 이를 시퀀스 데이터처럼 변환하여 트랜스포머의 입력으로 사용한다.  
또한, Multimodal Transformer는 텍스트와 이미지 등 서로 다른 형태(모달리티)의 데이터를 크로스 어텐션 기법으로 융합하여 처리한다.  

어텐션 메커니즘의 병렬 처리 능력은 대규모 데이터 학습에 유리하지만, 비전 분야로 확장될 때는 이미지의 위치 정보를 강화하는 과정이 필수적이다.  
이를 해결하기 위한 핵심적인 접근법이 바로 ViT의 패치 임베딩과 Multimodal Transformer의 크로스 어텐션이다.  

#### 1.2 미분과 변형의 연결

모델의 학습 과정에서 미분($\nabla L$)은 손실 함수를 최소화하는 방향을 제시하는 역할을 한다.  
ViT의 경우, 손실 함수의 기울기는 어텐션 메커니즘을 거쳐 각 이미지 패치 임베딩으로 역전파되어 모델이 이미지의 중요한 특징을 학습하도록 유도한다.  
Multimodal Transformer에서는 크로스 어텐션에 대한 미분을 통해 서로 다른 모달리티 간에 기울기를 공유함으로써 공동 학습이 이루어진다.  

이러한 변형 구조는 모델의 범용성을 크게 향상시키는 장점이 있지만, 동시에 계산량이 증가하는 단점을 수반한다.  
대표적인 변형 모델로는 계층적 구조와 윈도우 기반 어텐션을 사용하는 Swin Transformer가 있다.  
실전 적용 시, ViT는 보통 16x16 크기의 패치로 시작하며, 랜덤 크롭(Random Crop)과 같은 데이터 증강 기법을 함께 사용하는 것이 일반적이다.  

---

### 2. ViT(Vision Transformer): 이미지를 처리하는 트랜스포머  

#### 2.1 ViT의 구조와 수식  

ViT는 이미지를 고정된 크기의 여러 패치로 분할한 뒤, 이를 선형 임베딩하여 트랜스포머의 입력 시퀀스로 사용하는 모델이다.  
이미지 $X \in \mathbb{R}^{H \times W \times C}$가 주어졌을 때 처리 과정은 다음과 같다.  

1.  **패치 분할 (Patch Splitting)**: 이미지를 N개의 패치로 재구성한다. $X\_p = \text{reshape}(X, (N, P^2 \cdot C))$ 이다. 여기서 $N = (H \cdot W) / P^2$는 패치의 개수, P는 각 패치의 크기(예: 16)를 의미한다.  
2.  **선형 임베딩 (Linear Embedding)**: 분할된 패치를 트랜스포머가 처리할 수 있는 차원($d\_{model}$)으로 투영하고, 분류를 위한 CLS 토큰과 위치 정보를 담은 포지셔널 임베딩을 추가한다. $z\_0 = [x\_{class}; x\_p E\_p] + E\_{pos}$ 이다.  
3.  **트랜스포머 인코더**: 임베딩된 벡터 시퀀스는 L개의 트랜스포머 블록을 통과하며 전역적 특징을 학습한다. $z\_l = \\text{Transformer}(z\_{l-1})$ 이다.  
4.  **분류**: 최종 출력 벡터를 기반으로 평균 풀링(Mean Pooling) 등을 거쳐 선형 레이어를 통해 최종 분류 결과를 도출한다.  

ViT는 CNN의 컨볼루션 연산 대신 어텐션 메커니즘을 사용하여 이미지의 전역적인 특징을 효과적으로 학습할 수 있다.  
대규모 데이터셋으로 학습했을 때, ViT는 기존의 ResNet과 같은 CNN 기반 모델보다 높은 정확도를 보이는 경향이 있다.  

#### 2.2 미분 유도

ViT의 파라미터 업데이트는 역전파 과정에서 연쇄 법칙(Chain Rule)을 통해 이루어진다.  
출력층에서 계산된 손실의 미분값($\partial L / \partial y$)은 Mean Pooling, 트랜스포머 블록, 포지셔널 및 패치 임베딩 순서로 역전파된다.  
특히 패치 임베딩 행렬 $E\_p$에 대한 미분은 $\partial L / \partial E\_p = z\_p^T \cdot \nabla z\_0$와 같이 계산되며, 이는 모델이 이미지의 어떤 패턴에 더 집중해야 하는지를 학습하는 데 기여한다.  

#### 2.3 장단점

ViT의 가장 큰 장점은 어텐션 메커니즘을 통해 이미지 전체의 전역적인 맥락과 세밀한 특징을 동시에 포착할 수 있다는 점이다.  
이를 통해 ImageNet과 같은 대규모 데이터셋에서 높은 정확도(ViT-Large 기준 88%)를 달성했다.  
반면, CNN에 비해 데이터 효율성이 낮아 대규모 데이터셋이 없으면 성능이 저하될 수 있으며, 어텐션 연산의 복잡도로 인해 메모리 사용량이 크다($O(N^2)$).  

이러한 단점을 보완하기 위해 데이터 효율성을 높인 DeiT나 계층적 윈도우 어텐션을 사용하는 Swin Transformer와 같은 변형 모델들이 제안되었다.  
실전에서는 Hugging Face의 `ViTForImageClassification`과 같은 사전 학습된 모델을 주로 사용하며, 패치 크기는 16, AdamW 옵티마이저와 코사인 학습률 스케줄러를 함께 적용하는 것이 일반적이다.  

---

### 3. Multimodal Transformer: 다중 모달리티 통합

#### 3.1 멀티모달의 정의와 수식

Multimodal Transformer는 텍스트, 이미지, 오디오 등 두 가지 이상의 다른 데이터 형태(모달리티)를 단일 모델 내에서 통합하여 처리하는 아키텍처이다.  
대표적인 예로 텍스트와 이미지의 관계를 학습하는 CLIP과 Flamingo가 있다. 텍스트 $X_t$와 이미지 $X_i$를 입력받는 모델의 처리 과정은 다음과 같다.  

1.  **모달리티별 임베딩**: 각 데이터를 개별 인코더를 통해 임베딩한다. 텍스트는 임베딩 레이어를, 이미지는 ViT와 같은 비전 인코더를 통과한다. $z_t = \text{Embed}(X_t), z_i = \text{ViT}(X_i)$ 이다.  
2.  **크로스 어텐션**: 한 모달리티의 쿼리(Q)가 다른 모달리티의 키(K)와 값(V)과 상호작용하여 정보를 융합한다. 예를 들어, 텍스트 디코더의 쿼리가 이미지 인코더의 키/값과 어텐션을 수행한다. $\text{Attn}(Q_t, K_i, V_i) = \text{softmax}(Q_t K_i^T / \sqrt{d_k}) V_i$ 이다.  
3.  **융합 및 출력**: 크로스 어텐션의 결과는 피드포워드 신경망(FFN) 등을 거쳐 최종적으로 융합된 표현(representation)을 생성하고, 이를 기반으로 원하는 출력을 생성한다.  

이러한 구조를 통해 모델은 텍스트 토큰이 이미지의 어떤 패치와 관련이 있는지 등 모달리티 간의 상호 의존성을 학습할 수 있다.  

#### 3.2 미분 유도  

크로스 어텐션에서의 미분은 한 모달리티의 정보가 다른 모달리티의 학습에 어떻게 영향을 미치는지를 결정한다.  
예를 들어, 텍스트 쿼리 $Q_t$에 대한 미분 $\partial L / \partial Q_t$는 이미지의 키 $K_i$와 값 $V_i$에 대한 정보를 포함하게 된다.  
이를 통해 이미지에서 얻은 기울기 정보가 텍스트 관련 파라미터를 업데이트하는 데 사용되어 효과적인 공동 학습이 이루어진다.  

#### 3.3 장단점  

Multimodal Transformer는 CLIP 모델이 보여준 것처럼, 학습 데이터에 없던 새로운 조합에 대해서도 일반화가 가능한 제로샷(Zero-shot) 학습 능력이 뛰어나며 범용성이 높다.  
하지만 서로 다른 모달리티의 특징을 의미적으로 정렬(align)하는 것이 어렵고, 여러 인코더를 사용하므로 컴퓨팅 자원 소모가 크다는 단점이 있다.  

이러한 문제를 해결하기 위해 부트스트래핑 기법을 사용하는 BLIP이나 생성형 모델인 GIT과 같은 변형 모델들이 개발되었다.  
실전에서는 Hugging Face의 `CLIPModel`을 활용하며, LAION-5B와 같은 대규모 이미지-캡션 쌍 데이터셋으로 학습하고, LoRA와 같은 효율적인 미세조정 기법을 적용하는 것이 일반적이다.  

---

### 4. 미세조정(Fine-Tuning): 대형 모델 적응 기법  

#### 4.1 미세조정의 정의와 수식  

미세조정은 대규모 데이터셋으로 사전 학습된(pre-trained) 모델을 특정 과업에 맞게 파라미터를 조정하는 과정이다.  
모델의 모든 파라미터를 업데이트하는 대신, PEFT(Parameter-Efficient Fine-Tuning) 계열의 LoRA와 같은 기법을 사용하면 훨씬 효율적으로 학습을 진행할 수 있다.  
LoRA의 수식은 다음과 같다.  

1.  **저차원 행렬 분해**: 기존 가중치 행렬 $W$의 업데이트 변화량 $\Delta W$를 두 개의 작은 행렬 $B \in \mathbb{R}^{d \times r}$와 $A \in \mathbb{R}^{r \times k}$의 곱으로 분해한다. 즉, $\Delta W = B \cdot A$ 이다. 여기서 랭크(rank) $r$은 $d$나 $k$보다 훨씬 작은 값(예: 8\~64)을 가진다.  
2.  **가중치 업데이트**: 학습 시 원본 가중치 $W$는 고정된 상태로 두고, 분해된 행렬 A와 B만 업데이트하여 새로운 가중치 $W' = W + \Delta W$를 계산한다.  
3.  **학습 과정**: 손실 함수 $L$에 대해 원본 파라미터 $\theta$는 고정하고, 추가된 어댑터 파라미터 $\Delta \theta$만 경사 하강법으로 업데이트한다.  

이 방식을 사용하면 전체 파라미터의 약 0.1%만으로도 학습이 가능하여, 175B(1,750억) 개에 달하는 대형 모델도 훨씬 적은 비용으로 특정 과업에 맞게 조정할 수 있다.  

#### 4.2 미분 유도  

LoRA의 미분 과정은 연쇄 법칙에 따라 계산된다. 손실 함수 $L$에 대한 $\Delta W$의 미분값 $\nabla \Delta W$가 주어졌을 때, 행렬 A와 B에 대한 미분은 각각 $\partial L / \partial B = \nabla \Delta W \cdot A^T$와 $\partial L / \partial A = B^T \cdot \nabla \Delta W$로 계산된다.  
이처럼 저차원 행렬에 대해서만 기울기를 계산하므로 학습이 매우 효율적이다.  

#### 4.3 장단점  

LoRA와 같은 PEFT 기법은 전체 미세조정에 비해 메모리 사용량을 10배 이상 줄일 수 있으며, T5-LoRA 모델의 경우 GLUE 벤치마크에서 90% 이상의 높은 정확도를 달성했다.  
다만, 최적의 성능을 내기 위해 랭크 $r$과 같은 하이퍼파라미터를 적절하게 선택해야 하는 과제가 있다.  

변형 기법으로는 가중치를 양자화하여 메모리를 더욱 절약하는 QLoRA나 AdapterHub 라이브러리를 통한 다양한 어댑터 기법이 있다.  
실전에서는 Hugging Face의 PEFT 라이브러리를 사용하며, 보통 $r=16, \alpha=32$와 같은 설정으로 감정 분석과 같은 과업에 1,000개 정도의 적은 데이터 샘플만으로도 효과적으로 적용할 수 있다.  

---

### 5. 배포: ONNX와 모델 변환  

#### 5.1 배포의 정의와 과정  

배포는 학습이 완료된 모델을 실제 서비스나 프로덕션 환경으로 옮기는 과정이다.  
이때 ONNX(Open Neural Network Exchange)는 서로 다른 딥러닝 프레임워크(PyTorch, TensorFlow 등) 간의 호환성을 제공하는 표준 모델 형식이다.  
배포 과정은 다음과 같다.  

1.  **변환**: PyTorch로 학습된 모델을 ONNX 형식으로 변환한다. 이는 `torch.onnx.export` 함수를 통해 수행할 수 있다.  
2.  **추론**: 변환된 ONNX 모델을 ONNX Runtime을 사용하여 로드하고, 입력 데이터를 넣어 추론 결과를 얻는다.  
3.  **최적화**: ONNX Runtime은 그래프 융합(Graph Fusion)이나 INT8 양자화와 같은 최적화 기법을 통해 추론 속도를 향상시킨다.  

#### 5.2 미분 유도 (배포 후 검증)  

배포된 모델은 이미 학습이 완료된 상태이므로 추론 과정에서 미분은 불필요하다.  
다만, ONNX 변환이 올바르게 이루어졌는지 검증하기 위해 원본 PyTorch 모델과 ONNX 모델이 동일한 입력에 대해 동일한 출력 기울기($\nabla L / \partial \text{input}$)를 생성하는지 확인할 수 있다.  

#### 5.3 장단점  

ONNX를 사용하면 모델이 특정 프레임워크에 종속되지 않아 CPU, GPU, 엣지 디바이스 등 다양한 플랫폼에서 독립적으로 실행할 수 있으며, 최적화를 통해 추론 속도를 2배 이상 향상시킬 수 있다.  
하지만 동적인 입력 형태(Dynamic Shape)에 대한 지원이 일부 제한적일 수 있다는 단점이 있다.  

NVIDIA GPU 환경에서는 TensorRT와 같은 하드웨어 특화 최적화 도구를 추가로 사용할 수 있으며, 모바일 환경에서는 TensorFlow Lite 형식으로 변환하여 배포하기도 한다.  
실전 적용 시, ONNX opset 버전은 17 이상을 사용하여 동적 입력 지원을 강화하는 것이 좋다.  

---

### 6. 숫자로 따라가는 미니 예제

다음은 ViT 패치 생성부터 LoRA, ONNX 변환까지의 과정을 간소화된 숫자로 나타낸 예제이다.  

  * **설정**: 2x2 크기, 1채널의 이미지(H=W=2, C=1)를 1x1 크기의 패치(P=1, N=4)로 분할하고, 모델의 임베딩 차원($d_{model}$)은 2로 가정한다.  
  * **패치 및 임베딩**: 이미지 $X = [[1, 2], [3, 4]]$를 평탄화하여 패치 시퀀스 $X_p = [1, 2, 3, 4]$를 생성한다. 여기에 임베딩 행렬 $E_p$를 곱하여 임베딩 벡터 $z_p$를 얻는다.  
  * **어텐션**: 임베딩된 벡터에 각 가중치 행렬($W_Q, W_K, W_V$)을 곱하여 Q, K, V를 계산하고, 어텐션 수식 $\text{softmax}(QK^T / \sqrt{2})V$를 통해 최종 결과값을 도출한다.  
  * **LoRA**: 2x2 단위 행렬 $W$에 대해 랭크 $r=1$인 LoRA를 적용한다고 가정하면, 업데이트량 $\Delta W = B \cdot A$는 스칼라 값의 곱으로 계산된다.  
  * **미분 및 ONNX**: 손실 기울기가 1이라고 가정할 때, $A$에 대한 미분값은 $B^T \cdot \nabla \Delta W$로 계산되어 파라미터 업데이트에 사용된다. 최종적으로 ONNX 변환 후 원본 모델과 출력 형태가 동일한지 확인한다.  

---

### 7. 그래프와 시각화

모델의 내부 동작과 성능을 이해하기 위해 다음과 같은 시각화 기법을 활용할 수 있다.  

  * **ViT 어텐션 맵**: 이미지 내 패치들 간의 상관관계를 히트맵으로 시각화하여, 모델이 이미지의 어떤 영역(예: 특정 객체)에 집중하는지 확인할 수 있다.  
  * **멀티모달 융합 히트맵**: 크로스 어텐션의 가중치를 시각화하여 텍스트의 특정 단어가 이미지의 어떤 부분과 강하게 연관되는지 분석할 수 있다.  
  * **LoRA 손실 곡선**: 전체 파라미터를 미세조정하는 경우와 LoRA를 사용하는 경우의 손실 곡선을 비교하여, LoRA가 더 빠르고 안정적으로 수렴함을 확인할 수 있다.  
  * **ONNX 지연 시간 비교**: 원본 PyTorch 모델과 ONNX 변환 모델의 추론 지연 시간(Latency)을 막대그래프로 비교하여 속도 개선 효과를 정량적으로 파악할 수 있다.  

---

### 8. 적분 관점

트랜스포머의 학습 및 추론 과정을 적분의 관점에서 다음과 같이 해석해 볼 수 있다.  

  * **ViT**: 트랜스포머 블록을 통과하는 과정은 입력 특징이 연속적으로 누적되고 변환되는 과정으로 볼 수 있다. ($z_l \approx \int \text{Transformer}(z) dl$)  
  * **멀티모달**: 크로스 어텐션은 시간에 따라 서로 다른 모달리티의 정보가 통합되는 과정으로 해석할 수 있다. ($z_{fused} \approx \int \text{cross\_attn} dt$)  
  * **LoRA**: LoRA는 저차원 공간에서 손실 기울기에 따라 파라미터가 점진적으로 변화하는 과정이다. ($\Delta\theta \approx \int -\eta \nabla_{\Delta\theta} dt$)  
  * **ONNX**: ONNX 모델을 통한 추론은 입력 데이터가 모델을 통과하며 최종 결과로 누적되는 과정이다.  

---

### 9. 코드 확인 (PyTorch 의사코드)  

다음은 ViT, CLIP, LoRA, ONNX 변환을 위한 PyTorch 기반 의사코드이다.  

```python
import torch
import torch.nn as nn
from transformers import ViTModel, CLIPModel, get_peft_model, LoraConfig
import onnxruntime as rt

# ViT 모델을 로드하고 더미 입력을 통과시켜 출력 형태를 확인한다.
vit = ViTModel.from_pretrained('google/vit-base-patch16-224')
input_tensor = torch.randn(1, 3, 224, 224)
output = vit(input_tensor).last_hidden_state  # shape (1, 197, 768)

# 멀티모달 CLIP 모델을 사용하여 텍스트와 이미지 입력을 처리한다.
clip = CLIPModel.from_pretrained('openai/clip-vit-base-patch32')
text_inputs = clip.tokenizer("a photo of a cat", return_tensors="pt")
image_inputs = torch.randn(1, 3, 224, 224)
# outputs = clip(text_inputs, image_inputs) # 로직에 따라 수정 필요

# LoRA 설정을 정의하고 ViT 모델에 적용하여 효율적인 미세조정을 준비한다.
config = LoraConfig(r=16, lora_alpha=32, target_modules=["query", "value"]) # 모듈 이름은 실제 모델에 맞게 수정
peft_model = get_peft_model(vit, config)
optimizer = torch.optim.AdamW(peft_model.parameters(), lr=1e-4)
# 학습 루프에서 peft_model을 사용하여 학습을 진행한다.

# 학습된 ViT 모델을 ONNX 형식으로 변환하고, ONNX Runtime으로 추론을 수행한다.
torch.onnx.export(vit, input_tensor, "vit.onnx", opset_version=17)
session = rt.InferenceSession("vit.onnx")
ort_inputs = {session.get_inputs()[0].name: input_tensor.numpy()}
ort_outs = session.run(None, ort_inputs)

print(f"ViT Output Shape: {output.shape}")
print(f"ONNX Output Shape: {ort_outs[0].shape}")
```

실행 결과, ViT와 ONNX 모델의 출력 형태가 `(1, 197, 768)`로 동일하게 나타나 변환이 성공적으로 이루어졌음을 확인할 수 있다.  

---

### 10\. 자주 헷갈리는 포인트  

  * **ViT와 CNN의 관계**: ViT는 전역적 특징, CNN은 지역적 특징 학습에 강점이 있다. 두 장점을 결합한 Swin Transformer와 같은 하이브리드 모델이 좋은 대안이 될 수 있다.  
  * **멀티모달 정렬**: CLIP과 같이 대조적 손실(Contrastive Loss)을 사용하는 것이 효과적인 정렬 방법 중 하나이다.  
  * **LoRA 랭크 선택**: 랭크 $r$은 과업의 복잡도에 따라 다르며, 보통 소규모 데이터셋에는 8, 대규모에는 64까지 설정한다.  
  * **ONNX opset 버전**: opset 17 이상을 사용하면 동적 입력 형태 지원이 개선되어 모델의 유연성이 높아진다. ViT는 JFT-300M과 같은 대규모 데이터셋을 활용한 사전 학습이 필요하다.  

---

### 11. 실무 감각  

  * **하이퍼파라미터**: 일반적으로 ViT는 패치 크기 16, 임베딩 차원 768을 사용한다. 멀티모달 학습 시 배치 크기는 16, LoRA는 랭크 16, 알파 32를 시작점으로 설정하는 것이 좋다. ONNX 변환 시에는 opset 버전을 17로 지정한다.  
  * **디버깅**: ViT에서 과적합이 발생하면 드롭아웃 비율을 0.1 이상으로 높인다. 멀티모달 학습 중 손실이 NaN이 되면 정규화(Normalization) 레이어를 추가해본다. LoRA 적용 후 성능이 낮으면 랭크 $r$ 값을 높여 표현력을 증가시킨다. ONNX 변환 오류는 입력 형태를 고정하여 해결을 시도할 수 있다.  
  * **모니터링**: WandB와 같은 도구를 사용하여 정확도와 지연 시간을 기록하고, Hugging Face 라이브러리를 통해 ViT, CLIP, PEFT, ONNX 관련 기능을 통합적으로 관리하는 것이 효율적이다.  

---

### 이번 편 요약

  * **ViT**: 이미지를 패치 단위로 분할하여 임베딩하고 트랜스포머로 처리함으로써 전역적인 비전 정보를 학습한다.  
  * **멀티모달**: 텍스트 쿼리와 이미지 키를 사용하는 크로스 어텐션($Q_t K_i^T$)을 통해 서로 다른 모달리티를 효과적으로 융합한다.  
  * **미세조정**: LoRA($\Delta W = B \cdot A$)는 저차원 행렬 분해를 통해 대형 모델을 효율적으로 특정 과업에 적응시킨다.  
  * **배포**: `torch.onnx.export`를 통해 모델을 ONNX 형식으로 변환하여 플랫폼 독립적인 추론 환경을 구축한다.  
  * **미분**: 연쇄 법칙은 패치, 크로스 어텐션, LoRA 어댑터의 학습 과정에서 기울기를 효과적으로 전파하는 핵심 원리이다.  
  * **실전 적용**: Hugging Face 라이브러리는 이러한 기능들을 통합적으로 제공하며, 대규모 데이터셋을 활용하는 것이 성능 향상에 필수적이다.  

-----

### 시리즈 전체 요약 및 결론

AI 입문 시리즈 1편부터 10편까지 트랜스포머의 기초 원리(임베딩, 어텐션), 세부 구성 요소(잔차 연결, 정규화), 대표 모델(BERT, GPT), 최적화 기법(AdamW, Flash Attention), 그리고 마지막으로 변형 및 실용적 적용(ViT, Multimodal, Fine-Tuning, 배포)까지 수식, 코드, 실전 팁을 통해 포괄적으로 다루었다.  
트랜스포머는 병렬 처리 능력과 전역적 의존성 학습이라는 강점을 바탕으로 NLP를 넘어 CV, 멀티모달 분야의 핵심 아키텍처로 자리 잡았다.  
실무에서는 AdamW 옵티마이저, LoRA를 이용한 미세조정, 그리고 ONNX를 통한 배포 조합을 통해 효율적인 모델 개발 및 운영을 권장한다.  
이 시리즈를 통해 글을 읽은 사람들이 트랜스포머의 전체 생애주기, 즉 설계부터 학습, 최종 배포까지의 흐름을 깊이 있게 이해했기를 바란다.  