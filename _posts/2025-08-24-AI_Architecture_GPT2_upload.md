---
layout: single
title:  "AI 아키텍쳐 2. GPT-2"
categories: "AI"
tag: "Architecture"
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## GPT-2
BERT가 문장의 숨은 의도를 파악하는 '독해' 능력의 새 시대를 열었다면, GPT-2(Generative Pre-trained Transformer 2)는 인간과 유사한 문장을 '창작'하는 능력으로 AI 패러다임을 전환시킨 모델이다.
OpenAI에서 개발한 이 모델은 단순히 다음 단어를 예측하는 것을 넘어, 문맥에 맞는 일관된 내러티브를 생성하는 놀라운 능력을 선보였다.
사용자가 제공한 짧은 프롬프트(prompt)에 이어 자연스러운 소설, 논리적인 뉴스 기사, 심지어 작동하는 코드까지 작성해내는 모습은 학계와 산업계에 큰 충격을 주었다.
오용의 위험성 때문에 단계적으로 모델을 공개했을 정도로 그 성능은 강력했다.
BERT와 동일한 트랜스포머에 뿌리를 두고 있으면서도 어떻게 '이해'가 아닌 '창조'의 길을 걷게 되었는지, 그 아름답고 심오한 아키텍쳐를 깊이 파헤쳐 보자.

## 아키텍쳐 구조
GPT-2의 핵심 철학은 **트랜스포머(Transformer)의 디코더(Decoder) 구조**만을 사용하여 언어의 생성적 측면을 극대화하는 것이다.
이는 마치 두뇌의 역할을 분리하는 것과 같다. BERT의 인코더는 주어진 문장 전체를 샅샅이 훑어보며 종합적으로 이해하는 분석적 뇌(analytical brain)와 같다면, GPT-2의 디코더는 이미 말한 내용을 바탕으로 다음에 할 말을 순차적으로 떠올리는 창의적 뇌(creative brain)와 같다.
이러한 특성 때문에 정보의 흐름이 엄격하게 **단방향(Unidirectional)**으로, 즉 왼쪽에서 오른쪽으로만 흐르는 자기회귀(Autoregressive) 방식을 채택한다.

GPT-2의 핵심 아키텍처는 트랜스포머의 디코더 블록을 여러 겹으로 높이 쌓아 올린 구조이다. 모델의 크기에 따라 그 깊이와 복잡성이 달라진다.

| 모델 이름 | 파라미터 수 | 디코더 레이어 (n_layer) | 임베딩 차원 (d_model) | 어텐션 헤드 수 (n_head) |
|---|---|---|---|---|
| GPT-2 Small | 1억 2400만 | 12 | 768 | 12 |
| GPT-2 Medium | 3억 5500만 | 24 | 1024 | 16 |
| GPT-2 Large | 7억 7400만 | 36 | 1280 | 20 |
| GPT-2 XL | 15억 5800만 | 48 | 1600 | 25 |

GPT-2의 전체적인 데이터 처리 및 생성 흐름은 다음과 같은 반복 루프로 이루어진다.

1.  **입력 표현 (Input Representation)**: 최초의 문맥(context)이 되는 문장을 모델이 이해할 수 있는 숫자 토큰의 시퀀스로 변환한다.
2.  **임베딩 (Embedding)**: 이 숫자 토큰들을 의미와 순서 정보를 함축한 고차원 벡터로 만든다. GPT-2는 토큰 임베딩과 위치 임베딩, 두 가지를 합산하여 사용한다.
3.  **트랜스포머 디코더 스택 (Transformer Decoder Stack)**: 임베딩된 벡터 시퀀스가 수십 개의 디코더 레이어를 순차적으로 통과한다. 각 디코더는 '마스크드 셀프 어텐션'을 통해 과거의 문맥을 깊이 있게 이해하고, 이를 바탕으로 마지막 토큰 위치에서 다음에 올 단어에 대한 예측을 준비한다.
4.  **출력 및 샘플링 (Output & Sampling)**: 마지막 디코더 레이어의 최종 출력 벡터는 어휘 사전(Vocabulary) 크기의 로짓(logit) 벡터로 변환된다. 여기에 소프트맥스 함수를 적용하여 모든 단어에 대한 확률 분포를 얻는다. 이 분포를 기반으로 다음 단어를 '선택'(샘플링)한다.
5.  **자기회귀 (Autoregression)**: 새로 선택된 단어를 기존 입력 시퀀스의 맨 뒤에 추가하고, 이 확장된 시퀀스를 다시 모델의 입력으로 넣어 다음 단어를 예측하는 과정을 반복한다. 이 과정을 통해 문장이 한 단어씩 자라나게 된다.

이제 각 구성 요소가 어떤 정교한 역할을 수행하는지 더욱 자세히 살펴보자.

## 각 레이어별 역할

GPT-2의 아름다움은 단순한 '다음 단어 예측'이라는 목표를 위해 각 레이어가 유기적으로 협력하여 문맥의 뉘앙스를 점진적으로 심화시키는 과정에 있다.

### **1. 임베딩 레이어 (Embedding Layer)**

모든 언어 모델의 출발점은 텍스트를 기계가 이해할 수 있는 숫자의 세계로 옮기는 것이다. GPT-2의 임베딩 레이어는 단어의 개별적 의미와 문장 내에서의 순서라는 두 가지 핵심 정보를 정교한 벡터에 새겨 넣는다.

* **토큰 임베딩 (Token Embeddings)**:
    * **역할**: 각 단어 또는 서브워드(subword) 조각을 고유한 의미 벡터로 변환한다.
    * **설명**: GPT-2는 BPE(Byte Pair Encoding)라는 토크나이저를 사용한다. BPE는 텍스트에서 가장 빈번하게 등장하는 문자 쌍을 하나의 새로운 토큰으로 병합하는 과정을 반복하여 어휘 사전을 구축한다. 예를 들어, 'deeper'와 'deepest'가 자주 등장한다면, 'deep'과 'er', 'est'를 별도의 토큰으로 학습할 가능성이 높다. 이를 통해 한정된 크기의 어휘 사전으로도 처음 보는 단어(OOV)를 유연하게 표현할 수 있으며, 단어의 형태론적 구조까지 학습할 수 있다. 각 토큰은 사전의 고유 ID에 매핑되고, 이 ID에 해당하는 고도로 훈련된 벡터(토큰 임베딩)로 변환된다.

* **위치 임베딩 (Position Embeddings)**:
    * **역할**: 단어의 절대적인 순서 정보를 모델에 명시적으로 알려준다.
    * **증명 (필요성)**: RNN이나 LSTM과 같은 순환 신경망은 데이터를 순차적으로 처리하며 자연스럽게 순서 정보를 내재화한다. 하지만 트랜스포머는 문장의 모든 토큰을 한 번에 병렬적으로 처리한다. 이는 엄청난 계산 효율성을 가져오지만, '어떤 단어가 먼저 나왔는가'에 대한 정보를 잃어버리는 대가를 치른다. "개가 사람을 물었다"와 "사람이 개를 물었다"는 완전히 다른 의미이지만, 트랜스포머의 어텐션 메커니즘만으로는 이 둘을 구분할 수 없다. 따라서 각 위치(0번, 1번, 2번, ..., n번)에 고유한 벡터를 학습시켜 토큰 임베딩에 더해준다. 이 '위치 각인'을 통해 GPT-2는 비로소 어순과 문법 구조를 이해하고, 문맥에 맞는 순서로 단어를 생성할 수 있게 된다.

BERT와 달리, GPT-2는 두 문장 간의 관계를 파악하는 사전 학습 과제(NSP)가 없으므로 문장을 구분하는 **세그먼트 임베딩은 사용하지 않는다.** 오직 단어의 의미와 위치 정보만이 초기 입력 벡터를 구성한다.
$$\text{Input Embedding} = \text{TokenEmbedding} + \text{PositionEmbedding}$$

### **2. 트랜스포머 디코더 레이어 (Transformer Decoder Layer)**

임베딩된 벡터 시퀀스는 GPT-2의 심장부인 트랜스포머 디코더 스택으로 공급된다. GPT-2 XL 모델의 경우, 이 과정이 48번이나 반복된다. 각 디코더 레이어는 이전 레이어의 출력을 입력으로 받아, 문맥 정보를 더욱 정교하고 추상적으로 가공하여 다음 단어를 예측하는 데 최적화된 표현으로 변환한다.

#### **2-1. 마스크드 멀티-헤드 셀프 어텐션 (Masked Multi-Head Self-Attention)**

  * **역할**: 문장을 생성할 때, 각 단어가 오직 자신을 포함한 '과거'의 단어들에게만 주의(Attention)를 기울이도록 강제한다. 즉, 미래의 정보를 엿보지 못하게 막는 '눈가리개' 역할을 한다.

  * **작동 원리 및 증명**:
    기본적인 작동 방식(Q, K, V 벡터 생성, 어텐션 스코어 계산 등)은 BERT의 셀프 어텐션과 동일하다. 하지만 결정적인 차이점은 **미래 차단 마스크(Look-ahead Mask)**에 있다.
    
    예를 들어, "A cute cat sleeps" 라는 문장에서 "sleeps" 다음에 올 단어를 예측한다고 가정해보자. "sleeps" 토큰의 Query 벡터는 문장 내 모든 단어의 Key 벡터와 내적을 수행하여 어텐션 점수를 계산한다.
    
    1.  **마스킹(Masking) 적용**: 어텐션 점수 행렬에 소프트맥스 함수를 적용하기 직전, 마스크 행렬이 더해진다. 이 마스크는 행렬의 상삼각(upper-triangular) 부분, 즉 현재 예측하려는 단어보다 뒤에 오는 단어들과의 관계를 나타내는 위치에 $-\infty$ 값을 가진다.
    2.  **미래 정보 차단**: 어텐션 점수에 $-\infty$가 더해진 위치는 소프트맥스 함수를 통과하면서 그 확률값이 0이 된다. 결과적으로 "sleeps"를 예측할 때 "A", "cute", "cat", "sleeps" 자신의 정보는 참고할 수 있지만, 그 뒤에 올 단어들의 정보는 완전히 차단된다.
    3.  **증명 (필요성)**: 만약 이 마스킹이 없다면, 모델은 다음 단어를 예측하는 훈련 과정에서 정답을 미리 보고 맞추는 것과 같다. 이는 아무런 학습 효과를 낳지 못한다. 마스킹은 GPT-2가 진정한 의미의 '추론'을 통해, 주어진 과거의 정보를 바탕으로 가장 그럴듯한 미래를 예측하는 능력을 배우도록 하는 핵심적인 장치이다.
    
    또한, BERT처럼 **멀티-헤드(Multi-Head)** 구조를 통해 이러한 어텐션을 병렬적으로 여러 번 수행한다. 각 헤드는 독립적인 관점에서 문맥을 분석한다. 예를 들어, 한 헤드는 주어와 동사의 수일치 같은 문법적 관계에 집중하고, 다른 헤드는 문맥의 전반적인 주제 일관성을, 또 다른 헤드는 특정 단어 쌍의 연어(collocation) 관계를 학습할 수 있다. 이 다양한 관점의 정보들을 종합하여 GPT-2는 훨씬 더 다각적이고 풍부한 문맥 표현을 생성해낸다.

#### **2-2. 피드 포워드 신경망 (Position-wise Feed-Forward Network)**

  * **역할**: 마스크드 셀프 어텐션을 통해 재조합된 문맥 정보를 비선형적으로 변환하고, 각 토큰의 표현을 더욱 깊고 풍부하게 만든다.
  * **작동 원리 및 증명**: 이 구성 요소는 BERT의 인코더에 있는 FFN과 구조적으로나 기능적으로 완전히 동일하다. 셀프 어텐션이 토큰 간의 '관계'를 재정립하는 역할을 한다면, FFN은 각 토큰이 가진 정보를 개별적으로 '심화'시키는 역할을 한다. 두 개의 선형 변환과 GELU 활성화 함수로 구성되며, 중간에 차원을 일시적으로 크게 확장($d_{model} \rightarrow d_{ff} \rightarrow d_{model}$)한다. 이 '작업 공간'의 확장은 모델이 어텐션을 통해 얻은 정보를 더 복잡하고 추상적인 특징으로 조합하고 추출할 수 있게 해준다. FFN이 없다면, 모델은 단순히 이전 토큰들의 정보를 선형적으로 조합하는 얕은 수준에 머물게 될 것이다.
    $$\text{FFN}(x) = \text{GELU}(xW_1 + b_1)W_2 + b_2$$

#### **2-3. 잔차 연결 및 레이어 정규화 (Add & Norm)**

  * **역할**: GPT-2 XL처럼 48개에 달하는 깊은 신경망의 학습 과정을 안정시키고, 정보의 흐름을 원활하게 한다.
  * **작동 원리 및 증명**: 이 역시 BERT와 동일한, 딥러닝의 핵심 기술이다. 각 하위 레이어(마스크드 셀프 어텐션, FFN)마다 입력과 출력을 그대로 더하는 **잔차 연결**은 역전파 시 그래디언트가 소실되지 않고 깊은 레이어까지 효과적으로 전달될 수 있는 '고속도로'를 제공한다. **레이어 정규화**는 각 레이어의 출력값 분포가 특정 범위로 치우치지 않도록 안정화시켜, 학습 속도를 높이고 모델이 불안정한 상태에 빠지는 것을 방지한다. 수십 층의 레이어를 쌓아 올리는 GPT-2와 같은 거대 모델에서 이 두 가지 장치가 없다면, 성공적인 학습은 거의 불가능했을 것이다.

## GPT-2의 학습 방식과 활용

아키텍처가 뼈대라면, 학습 방식은 모델에 영혼을 불어넣는 과정이다. GPT-2의 진정한 힘은 방대한 비정형 데이터로부터 언어의 보편적인 패턴을 스스로 터득하는 사전 학습 과정에서 나온다.

### **1. 표준 언어 모델링 (Standard Language Modeling)**

  * **목표**: 주어진 텍스트 시퀀스를 보고, 바로 다음에 올 단어를 정확히 예측하는, 언어 모델링의 가장 고전적이고 순수한 과제를 수행한다.
  * **방식**: 이를 위해 OpenAI는 'WebText'라는 고품질의 대규모 데이터셋을 구축했다. 이는 약 40GB에 달하는 텍스트 데이터로, 소셜 미디어 플랫폼 Reddit에서 높은 평가를 받은 링크의 웹페이지만을 스크랩하여 만들어졌다. 광고나 스팸 등 저품질 텍스트를 최소화한 이 데이터셋 위에서, GPT-2는 수많은 문장을 읽으며 매 순간 다음 단어가 무엇일지 예측하는 훈련을 반복한다. "The quick brown fox jumps over"가 주어지면, "the"라는 다음 단어의 확률을 가장 높게 예측해야 한다. 손실 함수는 모델의 예측 확률 분포와 실제 정답 단어 간의 차이를 줄이는 Cross-Entropy Loss를 사용한다.
  * **증명 (학습 효과)**:
    이 지극히 단순한 '다음 단어 맞추기'라는 단일 목표는 역설적으로 모델이 언어의 거의 모든 측면을 학습하도록 유도한다. 올바른 다음 단어를 예측하기 위해서는 문법 구조, 단어의 의미, 문맥의 논리적 흐름, 세상에 대한 사실적 지식, 심지어 글의 스타일과 감성까지 이해해야만 한다. BERT처럼 여러 개의 복잡한 학습 목표(MLM, NSP)를 두는 대신, GPT-2는 이 하나의 순수한 목표를 거대한 모델과 데이터로 밀어붙임으로써 놀랍도록 일반화된 언어 능력을 획득할 수 있음을 증명했다.

### **2. 제로샷/퓨샷 학습 (Zero/Few-shot Learning)**

사전 학습된 GPT-2는 특정 과제를 위해 추가적인 학습(Fine-tuning)을 하지 않고도, 프롬프트(지시문)만으로 다양한 문제를 해결하는 능력을 보여주었다.

* **제로샷(Zero-shot)**: "Translate English to French: sea otter =>" 와 같은 지시문만 주면, 모델이 추가 학습 없이 "loutre de mer"라고 번역을 수행한다.
* **퓨샷(Few-shot)**: 몇 개의 예시를 함께 제공하면 모델의 성능이 더욱 향상된다.

이는 GPT-2가 단순히 패턴을 암기한 것이 아니라, 언어적 과제를 해결하는 일반적인 능력을 내재화했음을 의미하며, 프롬프팅을 통한 AI와의 상호작용 가능성을 열었다.

## 결론

GPT-2는 트랜스포머의 디코더 아키텍처와 대규모 자기회귀 언어 모델링의 잠재력을 폭발시킨 기념비적인 모델이다.
BERT가 양방향 문맥을 통해 언어를 깊이 있게 '분석'하는 길을 제시했다면, GPT-2는 단방향 문맥을 순차적으로 쌓아가며 새로운 텍스트를 '창조'하는 생성 AI 시대의 서막을 열었다.
'이해'를 넘어 '생성'으로 나아간 GPT-2의 철학과 아키텍처는 GPT-3, 그리고 현재 우리가 사용하는 ChatGPT와 같은 초거대 언어 모델(LLM)의 직접적인 조상이 되었으며, AI 기술의 패러다임을 영구적으로 바꾸어 놓았다.
마지막으로, GPT-2의 다양한 모델들을 직접 사용해볼 수 있는 링크를 남기며 글을 마친다.
[https://huggingface.co/gpt2](https://huggingface.co/gpt2)
[https://huggingface.co/openai-community/gpt2-large](https://huggingface.co/openai-community/gpt2-large)
[https://huggingface.co/openai-community/gpt2-xl](https://huggingface.co/openai-community/gpt2-xl)