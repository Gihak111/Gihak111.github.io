<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenge Map Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        #instructions h1 {
            color: #ff6ec7;
            margin-bottom: 20px;
        }
        #instructions button {
            background: #00d4ff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #instructions button:hover {
            background: #00a8cc;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>ë©: <span id="lap">1</span>/3</div>
        <div>ì†ë„: <span id="speed">0</span> km/h</div>
        <div>ì‹œê°„: <span id="time">0:00</span></div>
    </div>
    <div id="instructions">
        <h1>ğŸ CHALLENGE MAP ğŸ</h1>
        <p style="font-size: 18px; margin: 10px 0;">í™”ì‚´í‘œ í‚¤ë¡œ ìš´ì „í•˜ì„¸ìš”!</p>
        <p>â†‘ ê°€ì† | â†“ ë¸Œë ˆì´í¬ | â† â†’ ì¡°í–¥</p>
        <button onclick="startGame()">ê²Œì„ ì‹œì‘</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, car, gameStarted = false;
        let keys = {};
        let carSpeed = 0;
        let carRotation = Math.PI / 2;
        let lap = 1;
        let startTime = 0;
        let checkpoints = [];
        let passedCheckpoints = new Set();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // ë² ì´ì§€ ë°°ê²½
            scene.fog = new THREE.Fog(0x000000, 50, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, -25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('gameCanvas'), antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // ì”ë”” (ì¤‘ì•™ ë…¹ìƒ‰ ì˜ì—­)
            const grassGeometry = new THREE.CircleGeometry(12, 64);
            const grassMaterial = new THREE.MeshLambertMaterial({color: 0x4a9d5f}); // ì—°í•œ ë…¹ìƒ‰
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.1;
            grass.receiveShadow = true;
            scene.add(grass);

            // íŠ¸ë™ ìƒì„±
            createMonzaTrack();

            // ë“±ëŒ€ (íŒŒë€ìƒ‰)
            createLighthouse();

            // ë‚˜ë¬´
            createTree();

            // ì²´í¬í¬ì¸íŠ¸ ìƒì„±
            createCheckpoints();

            // ìë™ì°¨
            createCar();

            // ê²°ìŠ¹ì„ 
            createFinishLine();

            // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', onWindowResize);
        }

        // ê¸°ì¡´ createOvalTrack í•¨ìˆ˜ë¥¼ ì§€ìš°ê³  ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”.
function createMonzaTrack() {
    // íŠ¸ë™ì˜ ì¬ì§ˆê³¼ ìƒ‰ìƒì„ ì„¤ì •í•©ë‹ˆë‹¤.
    const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a5a });
    const trackWidth = 5; // íŠ¸ë™ í­ì„ ì•½ê°„ ë„“ê²Œ ì¡°ì •

    // ëª¬ì°¨ ì„œí‚·ì˜ ì£¼ìš” ì§€ì  ì¢Œí‘œë“¤ì…ë‹ˆë‹¤. ì´ ì¢Œí‘œë¥¼ ìˆ˜ì •í•˜ì—¬ íŠ¸ë™ ëª¨ì–‘ì„ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    const waypoints = [
        { x: 10,  z: -45 }, // Start/Finish Straight
        { x: 130, z: -45 },
        { x: 140, z: -50 }, // Variante del Rettifilo (chicane 1)
        { x: 135, z: -60 },
        { x: 125, z: -60 },
        { x: 100, z: -40 }, // Curva Grande
        { x: 60,  z: 0 },
        { x: 30,  z: 30 },
        { x: 20,  z: 40 },  // Variante della Roggia (chicane 2)
        { x: 15,  z: 45 },
        { x: 10,  z: 45 },
        { x: 0,   z: 50 },  // Curve di Lesmo (two corners)
        { x: -15, z: 55 },
        { x: -30, z: 50 },
        { x: -40, z: 45 },
        { x: -60, z: 40 },  // Curva del Serraglio
        { x: -90, z: 30 },
        { x: -100,z: 35 },  // Variante Ascari (chicane 3)
        { x: -110,z: 30 },
        { x: -115,z: 20 },
        { x: -110,z: 5 },   // Back straight
        { x: -90, z: -20 }, // Curva Parabolica
        { x: -60, z: -40 },
        { x: -20, z: -45 },
    ];

    // 1. Vector3 í˜•íƒœë¡œ ë³€í™˜
    const points = waypoints.map(p => new THREE.Vector3(p.x, 0, p.z));

    // 2. CatmullRomCurve3ë¥¼ ì‚¬ìš©í•´ ì¢Œí‘œë“¤ì„ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
    // .closed = trueë¡œ ì„¤ì •í•˜ì—¬ ì‹œì‘ì ê³¼ ëì ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°í•©ë‹ˆë‹¤.
    const curve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);

    // 3. ê³¡ì„ ì„ 500ê°œì˜ ì¡°ë°€í•œ ì ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ë¶€ë“œëŸ¬ìš´ ê²½ë¡œë¥¼ ì–»ìŠµë‹ˆë‹¤.
    const smoothPoints = curve.getPoints(500);

    // 4. ì¡°ë°€í•œ ì ë“¤ì„ ìˆœíšŒí•˜ë©° ì§§ì€ ì§ì„  íŠ¸ë™ ì¡°ê°ë“¤ì„ ë§Œë“¤ì–´ ì—°ê²°í•©ë‹ˆë‹¤.
    for (let i = 0; i < smoothPoints.length - 1; i++) {
        const p1 = smoothPoints[i];
        const p2 = smoothPoints[i + 1];

        const length = p1.distanceTo(p2);
        const segmentAngle = Math.atan2(p2.x - p1.x, p2.z - p1.z);

        const trackGeometry = new THREE.BoxGeometry(trackWidth, 0.2, length);
        const trackSegment = new THREE.Mesh(trackGeometry, trackMaterial);

        trackSegment.position.set((p1.x + p2.x) / 2, -0.1, (p1.z + p2.z) / 2);
        trackSegment.rotation.y = segmentAngle;
        trackSegment.receiveShadow = true;
        scene.add(trackSegment);

        // ì¤‘ì•™ì„  (í°ìƒ‰ ì ì„ )
        if (i % 10 === 0) {
            const lineGeometry = new THREE.BoxGeometry(0.15, 0.25, length);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set((p1.x + p2.x) / 2, -0.05, (p1.z + p2.z) / 2);
            line.rotation.y = segmentAngle;
            scene.add(line);
        }
    }
    
    // ë³µì¡í•œ íŠ¸ë™ì—ì„œëŠ” ì²´í¬í¬ì¸íŠ¸ì™€ ê²°ìŠ¹ì„  ë¡œì§ì„ ë‹¤ì‹œ ì„¤ê³„í•´ì•¼ í•˜ë¯€ë¡œ,
    // ê¸°ì¡´ì˜ createCheckpoints(), createFinishLine() í•¨ìˆ˜ëŠ” ë¹„í™œì„±í™”í•˜ê±°ë‚˜ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
    // ì—¬ê¸°ì„œëŠ” íŠ¸ë™ ëª¨ì–‘ ìì²´ì— ì§‘ì¤‘í•˜ê¸° ìœ„í•´ í•´ë‹¹ ë¡œì§ì€ ì ì‹œ ë¹„ì›Œë‘¡ë‹ˆë‹¤.
}

        function createLighthouse() {
            // ë“±ëŒ€ ê¸°ë‘¥ (íŒŒë€ìƒ‰)
            const baseGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
            const baseMaterial = new THREE.MeshLambertMaterial({color: 0x2b5aa0});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 2, 0);
            base.castShadow = true;
            scene.add(base);

            // ë“±ëŒ€ ìƒë‹¨ (í°ìƒ‰)
            const topGeometry = new THREE.CylinderGeometry(0.6, 0.5, 1, 8);
            const topMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(0, 4.5, 0);
            top.castShadow = true;
            scene.add(top);

            // ë“±ëŒ€ ë¹›
            const lightGeometry = new THREE.CylinderGeometry(0.7, 0.6, 0.5, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.set(0, 5.2, 0);
            scene.add(light);
        }

        function createTree() {
            // ë‚˜ë¬´ ì¤„ê¸° (ê°ˆìƒ‰)
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({color: 0x6b4423});
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(-8, 1, 5);
            trunk.castShadow = true;
            scene.add(trunk);

            // ë‚˜ë¬´ ì (ë…¹ìƒ‰)
            const leavesGeometry = new THREE.SphereGeometry(1.2, 8, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({color: 0x2d5016});
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(-8, 2.8, 5);
            leaves.castShadow = true;
            scene.add(leaves);
        }

        // ì´ ì½”ë“œë¡œ ê¸°ì¡´ createCheckpoints í•¨ìˆ˜ ì „ì²´ë¥¼ êµì²´í•˜ì„¸ìš”.
        function createCheckpoints() {
            // ê° ì²´í¬í¬ì¸íŠ¸ì˜ ê¸°ì¡´ rotation ê°’ì— 90ë„(Math.PI / 2)ë¥¼ ë”í–ˆìŠµë‹ˆë‹¤.
            const checkpointPositions = [
                // 1. ì²« ë²ˆì§¸ ì‹œì¼€ì¸ í†µê³¼ í›„, ì¿ ë¥´ë°” ê·¸ë€ë° ì»¤ë¸Œ
                {x: 80, z: -20, rotation: (Math.PI / 4) + (Math.PI / 2)},
                // 2. ë ˆì¦ˆëª¨ ì»¤ë¸Œ í†µê³¼ í›„, ì„¸ë¼ê¸€ë¦¬ì˜¤ ì§ì„ ì£¼ë¡œ
                {x: -45, z: 48, rotation: (-Math.PI / 6) + (Math.PI / 2)},
                // 3. ì•„ìŠ¤ì¹´ë¦¬ ì‹œì¼€ì¸ í†µê³¼ í›„, íŒŒë¼ë³¼ë¦¬ì¹´ë¡œ í–¥í•˜ëŠ” ì§ì„ ì£¼ë¡œ
                {x: -112, z: 10, rotation: (Math.PI / 2.5) + (Math.PI / 2)},
                // 4. íŒŒë¼ë³¼ë¦¬ì¹´ íƒˆì¶œ í›„, ê²°ìŠ¹ì„  í†µê³¼ ì§ì „
                {x: -10, z: -45, rotation: 0 + (Math.PI / 2)}
            ];

            checkpointPositions.forEach((pos, index) => {
                const geometry = new THREE.BoxGeometry(6, 0.1, 0.5);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.35
                });
                const checkpoint = new THREE.Mesh(geometry, material);
                checkpoint.position.set(pos.x, 0.5, pos.z);
                checkpoint.rotation.y = pos.rotation;
                checkpoint.userData.id = index;
                checkpoints.push(checkpoint);
                scene.add(checkpoint);
            });
        }

        function createCar() {
            const carGroup = new THREE.Group();

            // ì°¨ì²´ (í°ìƒ‰)
            const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 1.8);
            const bodyMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            // ì°¨ ìƒë‹¨
            const topGeometry = new THREE.BoxGeometry(0.8, 0.4, 1);
            const topMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 0.95;
            top.castShadow = true;
            carGroup.add(top);

            // ë°”í€´
            const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({color: 0x333333});
            
            const wheelPositions = [
                {x: -0.6, y: 0.25, z: 0.6},
                {x: 0.6, y: 0.25, z: 0.6},
                {x: -0.6, y: 0.25, z: -0.6},
                {x: 0.6, y: 0.25, z: -0.6}
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            carGroup.position.set(15, 0.3, -45);
            car = carGroup;
            scene.add(car);
        }

        // ì´ ì½”ë“œë¡œ ê¸°ì¡´ createFinishLine í•¨ìˆ˜ ì „ì²´ë¥¼ êµì²´í•˜ì„¸ìš”.
        function createFinishLine() {
            // ì²´í¬ë¬´ëŠ¬ ê²°ìŠ¹ì„ 
            const finishGeometry = new THREE.BoxGeometry(6, 0.25, 1.5);
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#ffffff' : '#000000';
                    ctx.fillRect(i * 8, j * 8, 8, 8);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const finishMaterial = new THREE.MeshBasicMaterial({map: texture});
            const finish = new THREE.Mesh(finishGeometry, finishMaterial);
            
            // ê²°ìŠ¹ì„  ìœ„ì¹˜ ì„¤ì •
            finish.position.set(15, 0.3, -45);
            
            // â–¼â–¼â–¼ ì´ ì¤„ì„ ì¶”ê°€í•˜ì—¬ ê²°ìŠ¹ì„ ì„ Yì¶• ê¸°ì¤€ìœ¼ë¡œ 90ë„ íšŒì „ì‹œí‚µë‹ˆë‹¤. â–¼â–¼â–¼
            finish.rotation.y = Math.PI / 2;
            
            scene.add(finish);
        }

        function startGame() {
            document.getElementById('instructions').classList.add('hidden');
            gameStarted = true;
            startTime = Date.now();
        }

        function updateCar() {
            if (!gameStarted) return;

            const maxSpeed = 0.5;
            const acceleration = 0.01;
            const friction = 0.98;
            const turnSpeed = 0.03;

            // ê°€ì†
            if (keys['ArrowUp']) {
                carSpeed = Math.min(carSpeed + acceleration, maxSpeed);
            }
            // ë¸Œë ˆì´í¬
            if (keys['ArrowDown']) {
                carSpeed = Math.max(carSpeed - acceleration * 2, -maxSpeed * 0.5);
            }

            // ë§ˆì°°
            carSpeed *= friction;

            // ì¡°í–¥
            if (keys['ArrowLeft'] && Math.abs(carSpeed) > 0.01) {
                carRotation += turnSpeed * (carSpeed > 0 ? 1 : -1);
            }
            if (keys['ArrowRight'] && Math.abs(carSpeed) > 0.01) {
                carRotation -= turnSpeed * (carSpeed > 0 ? 1 : -1);
            }

            // ì°¨ ì´ë™
            car.position.x += Math.sin(carRotation) * carSpeed;
            car.position.z += Math.cos(carRotation) * carSpeed;
            car.rotation.y = carRotation;

            // ì²´í¬í¬ì¸íŠ¸ í™•ì¸
            checkpoints.forEach(checkpoint => {
                const distance = car.position.distanceTo(checkpoint.position);
                if (distance < 4) {
                    passedCheckpoints.add(checkpoint.userData.id);
                    
                    // ëª¨ë“  ì²´í¬í¬ì¸íŠ¸ í†µê³¼ í›„ ê²°ìŠ¹ì„ 
                    if (passedCheckpoints.size === checkpoints.length &&
                        car.position.z < -43 && Math.abs(car.position.x - 15) < 5) {
                        lap++;
                        passedCheckpoints.clear();
                        
                        if (lap > 3) {
                            alert('ğŸ ë ˆì´ìŠ¤ ì™„ë£Œ! ì‹œê°„: ' + document.getElementById('time').textContent);
                            lap = 1;
                            // ì‹œì‘ ìœ„ì¹˜ì™€ ê°ë„ë¥¼ ì´ˆê¸°í™”
                            car.position.set(15, 0.3, -45);
                            carRotation = 0; // ì‹œì‘ ê°ë„ë„ ì´ˆê¸°í™”
                            car.rotation.y = carRotation;
                            carSpeed = 0;
                            startTime = Date.now();
                        }
                    }
                }
            });

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('lap').textContent = lap;
            document.getElementById('speed').textContent = Math.round(Math.abs(carSpeed) * 200);
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateCamera() {
            if (!car) return;
            
            const cameraOffset = new THREE.Vector3(
                Math.sin(carRotation) * -8,
                6,
                Math.cos(carRotation) * -8
            );
            
            camera.position.x += (car.position.x + cameraOffset.x - camera.position.x) * 0.1;
            camera.position.y += (car.position.y + cameraOffset.y - camera.position.y) * 0.1;
            camera.position.z += (car.position.z + cameraOffset.z - camera.position.z) * 0.1;
            
            camera.lookAt(car.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCar();
            updateCamera();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>
