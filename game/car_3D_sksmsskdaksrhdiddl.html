<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenge Map Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        #instructions h1 {
            color: #ff6ec7;
            margin-bottom: 20px;
        }
        #instructions button {
            background: #00d4ff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #instructions button:hover {
            background: #00a8cc;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>랩: <span id="lap">1</span>/3</div>
        <div>속도: <span id="speed">0</span> km/h</div>
        <div>시간: <span id="time">0:00</span></div>
    </div>
    <div id="instructions">
        <h1>🏁 CHALLENGE MAP 🏁</h1>
        <p style="font-size: 18px; margin: 10px 0;">화살표 키로 운전하세요!</p>
        <p>↑ 가속 | ↓ 브레이크 | ← → 조향</p>
        <button onclick="startGame()">게임 시작</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, car, gameStarted = false;
        let keys = {};
        let carSpeed = 0;
        let carRotation = Math.PI / 2;
        let lap = 1;
        let startTime = 0;
        let checkpoints = [];
        let passedCheckpoints = new Set();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // 베이지 배경
            scene.fog = new THREE.Fog(0x000000, 50, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, -25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('gameCanvas'), antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // 잔디 (중앙 녹색 영역)
            const grassGeometry = new THREE.CircleGeometry(12, 64);
            const grassMaterial = new THREE.MeshLambertMaterial({color: 0x4a9d5f}); // 연한 녹색
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.1;
            grass.receiveShadow = true;
            scene.add(grass);

            // 트랙 생성
            createMonzaTrack();

            // 등대 (파란색)
            createLighthouse();

            // 나무
            createTree();

            // 체크포인트 생성
            createCheckpoints();

            // 자동차
            createCar();

            // 결승선
            createFinishLine();

            // 키보드 이벤트
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);

            // 윈도우 리사이즈
            window.addEventListener('resize', onWindowResize);
        }

        // 기존 createOvalTrack 함수를 지우고 아래 코드로 교체하세요.
function createMonzaTrack() {
    // 트랙의 재질과 색상을 설정합니다.
    const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a5a });
    const trackWidth = 5; // 트랙 폭을 약간 넓게 조정

    // 몬차 서킷의 주요 지점 좌표들입니다. 이 좌표를 수정하여 트랙 모양을 바꿀 수 있습니다.
    const waypoints = [
        { x: 10,  z: -45 }, // Start/Finish Straight
        { x: 130, z: -45 },
        { x: 140, z: -50 }, // Variante del Rettifilo (chicane 1)
        { x: 135, z: -60 },
        { x: 125, z: -60 },
        { x: 100, z: -40 }, // Curva Grande
        { x: 60,  z: 0 },
        { x: 30,  z: 30 },
        { x: 20,  z: 40 },  // Variante della Roggia (chicane 2)
        { x: 15,  z: 45 },
        { x: 10,  z: 45 },
        { x: 0,   z: 50 },  // Curve di Lesmo (two corners)
        { x: -15, z: 55 },
        { x: -30, z: 50 },
        { x: -40, z: 45 },
        { x: -60, z: 40 },  // Curva del Serraglio
        { x: -90, z: 30 },
        { x: -100,z: 35 },  // Variante Ascari (chicane 3)
        { x: -110,z: 30 },
        { x: -115,z: 20 },
        { x: -110,z: 5 },   // Back straight
        { x: -90, z: -20 }, // Curva Parabolica
        { x: -60, z: -40 },
        { x: -20, z: -45 },
    ];

    // 1. Vector3 형태로 변환
    const points = waypoints.map(p => new THREE.Vector3(p.x, 0, p.z));

    // 2. CatmullRomCurve3를 사용해 좌표들을 부드러운 곡선으로 만듭니다.
    // .closed = true로 설정하여 시작점과 끝점을 자연스럽게 연결합니다.
    const curve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);

    // 3. 곡선을 500개의 조밀한 점으로 분할하여 부드러운 경로를 얻습니다.
    const smoothPoints = curve.getPoints(500);

    // 4. 조밀한 점들을 순회하며 짧은 직선 트랙 조각들을 만들어 연결합니다.
    for (let i = 0; i < smoothPoints.length - 1; i++) {
        const p1 = smoothPoints[i];
        const p2 = smoothPoints[i + 1];

        const length = p1.distanceTo(p2);
        const segmentAngle = Math.atan2(p2.x - p1.x, p2.z - p1.z);

        const trackGeometry = new THREE.BoxGeometry(trackWidth, 0.2, length);
        const trackSegment = new THREE.Mesh(trackGeometry, trackMaterial);

        trackSegment.position.set((p1.x + p2.x) / 2, -0.1, (p1.z + p2.z) / 2);
        trackSegment.rotation.y = segmentAngle;
        trackSegment.receiveShadow = true;
        scene.add(trackSegment);

        // 중앙선 (흰색 점선)
        if (i % 10 === 0) {
            const lineGeometry = new THREE.BoxGeometry(0.15, 0.25, length);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set((p1.x + p2.x) / 2, -0.05, (p1.z + p2.z) / 2);
            line.rotation.y = segmentAngle;
            scene.add(line);
        }
    }
    
    // 복잡한 트랙에서는 체크포인트와 결승선 로직을 다시 설계해야 하므로,
    // 기존의 createCheckpoints(), createFinishLine() 함수는 비활성화하거나 수정해야 합니다.
    // 여기서는 트랙 모양 자체에 집중하기 위해 해당 로직은 잠시 비워둡니다.
}

        function createLighthouse() {
            // 등대 기둥 (파란색)
            const baseGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
            const baseMaterial = new THREE.MeshLambertMaterial({color: 0x2b5aa0});
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(0, 2, 0);
            base.castShadow = true;
            scene.add(base);

            // 등대 상단 (흰색)
            const topGeometry = new THREE.CylinderGeometry(0.6, 0.5, 1, 8);
            const topMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(0, 4.5, 0);
            top.castShadow = true;
            scene.add(top);

            // 등대 빛
            const lightGeometry = new THREE.CylinderGeometry(0.7, 0.6, 0.5, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.set(0, 5.2, 0);
            scene.add(light);
        }

        function createTree() {
            // 나무 줄기 (갈색)
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({color: 0x6b4423});
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(-8, 1, 5);
            trunk.castShadow = true;
            scene.add(trunk);

            // 나무 잎 (녹색)
            const leavesGeometry = new THREE.SphereGeometry(1.2, 8, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({color: 0x2d5016});
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(-8, 2.8, 5);
            leaves.castShadow = true;
            scene.add(leaves);
        }

        // 이 코드로 기존 createCheckpoints 함수 전체를 교체하세요.
        function createCheckpoints() {
            // 각 체크포인트의 기존 rotation 값에 90도(Math.PI / 2)를 더했습니다.
            const checkpointPositions = [
                // 1. 첫 번째 시케인 통과 후, 쿠르바 그란데 커브
                {x: 80, z: -20, rotation: (Math.PI / 4) + (Math.PI / 2)},
                // 2. 레즈모 커브 통과 후, 세라글리오 직선주로
                {x: -45, z: 48, rotation: (-Math.PI / 6) + (Math.PI / 2)},
                // 3. 아스카리 시케인 통과 후, 파라볼리카로 향하는 직선주로
                {x: -112, z: 10, rotation: (Math.PI / 2.5) + (Math.PI / 2)},
                // 4. 파라볼리카 탈출 후, 결승선 통과 직전
                {x: -10, z: -45, rotation: 0 + (Math.PI / 2)}
            ];

            checkpointPositions.forEach((pos, index) => {
                const geometry = new THREE.BoxGeometry(6, 0.1, 0.5);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.35
                });
                const checkpoint = new THREE.Mesh(geometry, material);
                checkpoint.position.set(pos.x, 0.5, pos.z);
                checkpoint.rotation.y = pos.rotation;
                checkpoint.userData.id = index;
                checkpoints.push(checkpoint);
                scene.add(checkpoint);
            });
        }

        function createCar() {
            const carGroup = new THREE.Group();

            // 차체 (흰색)
            const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 1.8);
            const bodyMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            // 차 상단
            const topGeometry = new THREE.BoxGeometry(0.8, 0.4, 1);
            const topMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 0.95;
            top.castShadow = true;
            carGroup.add(top);

            // 바퀴
            const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({color: 0x333333});
            
            const wheelPositions = [
                {x: -0.6, y: 0.25, z: 0.6},
                {x: 0.6, y: 0.25, z: 0.6},
                {x: -0.6, y: 0.25, z: -0.6},
                {x: 0.6, y: 0.25, z: -0.6}
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            carGroup.position.set(15, 0.3, -45);
            car = carGroup;
            scene.add(car);
        }

        // 이 코드로 기존 createFinishLine 함수 전체를 교체하세요.
        function createFinishLine() {
            // 체크무늬 결승선
            const finishGeometry = new THREE.BoxGeometry(6, 0.25, 1.5);
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#ffffff' : '#000000';
                    ctx.fillRect(i * 8, j * 8, 8, 8);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const finishMaterial = new THREE.MeshBasicMaterial({map: texture});
            const finish = new THREE.Mesh(finishGeometry, finishMaterial);
            
            // 결승선 위치 설정
            finish.position.set(15, 0.3, -45);
            
            // ▼▼▼ 이 줄을 추가하여 결승선을 Y축 기준으로 90도 회전시킵니다. ▼▼▼
            finish.rotation.y = Math.PI / 2;
            
            scene.add(finish);
        }

        function startGame() {
            document.getElementById('instructions').classList.add('hidden');
            gameStarted = true;
            startTime = Date.now();
        }

        function updateCar() {
            if (!gameStarted) return;

            const maxSpeed = 0.5;
            const acceleration = 0.01;
            const friction = 0.98;
            const turnSpeed = 0.03;

            // 가속
            if (keys['ArrowUp']) {
                carSpeed = Math.min(carSpeed + acceleration, maxSpeed);
            }
            // 브레이크
            if (keys['ArrowDown']) {
                carSpeed = Math.max(carSpeed - acceleration * 2, -maxSpeed * 0.5);
            }

            // 마찰
            carSpeed *= friction;

            // 조향
            if (keys['ArrowLeft'] && Math.abs(carSpeed) > 0.01) {
                carRotation += turnSpeed * (carSpeed > 0 ? 1 : -1);
            }
            if (keys['ArrowRight'] && Math.abs(carSpeed) > 0.01) {
                carRotation -= turnSpeed * (carSpeed > 0 ? 1 : -1);
            }

            // 차 이동
            car.position.x += Math.sin(carRotation) * carSpeed;
            car.position.z += Math.cos(carRotation) * carSpeed;
            car.rotation.y = carRotation;

            // 체크포인트 확인
            checkpoints.forEach(checkpoint => {
                const distance = car.position.distanceTo(checkpoint.position);
                if (distance < 4) {
                    passedCheckpoints.add(checkpoint.userData.id);
                    
                    // 모든 체크포인트 통과 후 결승선
                    if (passedCheckpoints.size === checkpoints.length &&
                        car.position.z < -43 && Math.abs(car.position.x - 15) < 5) {
                        lap++;
                        passedCheckpoints.clear();
                        
                        if (lap > 3) {
                            alert('🏁 레이스 완료! 시간: ' + document.getElementById('time').textContent);
                            lap = 1;
                            // 시작 위치와 각도를 초기화
                            car.position.set(15, 0.3, -45);
                            carRotation = 0; // 시작 각도도 초기화
                            car.rotation.y = carRotation;
                            carSpeed = 0;
                            startTime = Date.now();
                        }
                    }
                }
            });

            // UI 업데이트
            document.getElementById('lap').textContent = lap;
            document.getElementById('speed').textContent = Math.round(Math.abs(carSpeed) * 200);
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateCamera() {
            if (!car) return;
            
            const cameraOffset = new THREE.Vector3(
                Math.sin(carRotation) * -8,
                6,
                Math.cos(carRotation) * -8
            );
            
            camera.position.x += (car.position.x + cameraOffset.x - camera.position.x) * 0.1;
            camera.position.y += (car.position.y + cameraOffset.y - camera.position.y) * 0.1;
            camera.position.z += (car.position.z + cameraOffset.z - camera.position.z) * 0.1;
            
            camera.lookAt(car.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCar();
            updateCamera();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>
