<!DOCTYPE html>
<!--
** ë§¤ìš° ì¤‘ìš” **
ì´ html ì´ ê°€ì§„ ëª¨ë“  ê¸°ëŠ¥ì„ ê°€ì§€ê³  ìˆëŠ” ì‚¬ì´íŠ¸ë¥¼ ë§Œë“¤ê³  ì‹¶ì–´
https://oneclickai-s3.s3.ap-northeast-2.amazonaws.com/ai-models/20250828_122558_199/model.json ì´ê±´ ì €ì¥ëœ ëª¨ë¸ s3 ê²½ë¡œ
ì´ html ì½”ë“œë¥¼ ì „ë¶€ í¬í•¨í•˜ê²Œ ë§Œë“¤ì–´ì•¼ í•´
-->
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³ ì–‘ì´, ê°•ì•„ì§€ ì‚¬ì§„ ë¶„ë¥˜ AI UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    :root {
    --primary-color: #4A90E2;
    --secondary-color: #50E3C2;
    --background-color: #F7F9FC;
    --card-background: #FFFFFF;
    --text-color: #333333;
    --border-color: #E0E0E0;
    --hover-color: #E3F2FD;
    --active-color: #B3E5FC;
    --loading-color: #4A90E2;
}

body {
    font-family: 'Roboto', sans-serif;
    background-color: var(--background-color);
    color: var(--text-color);
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.card {
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s ease;
}

.card:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.button {
    background-color: var(--primary-color);
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease;
}

.button:hover {
    background-color: var(--hover-color);
}

.button:active {
    background-color: var(--active-color);
    transform: scale(0.95);
}

.loading {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 4px solid var(--loading-color);
    border-top: 4px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.input {
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 10px;
    width: 100%;
    transition: border-color 0.3s ease;
}

.input:focus {
    border-color: var(--primary-color);
    outline: none;
}

.text-center {
    text-align: center;
}

.mt-4 {
    margin-top: 1rem;
}

.mb-4 {
    margin-bottom: 1rem;
}
    body { 
      margin: 0;
      padding: 0;
    }
    </style>
</head>
<body>
    <div id="ai-ui-root" class="container mx-auto p-4">
        <div id="model-test-section"></div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
<script>
    // ì—¬ê¸°ì—ëŠ” ìˆœìˆ˜í•˜ê²Œ React ì•±ì„ êµ¬ë™í•˜ëŠ” ì½”ë“œë§Œ ë‚¨ìŠµë‹ˆë‹¤.
    let tf, use, React, ReactDOM;
    
    function waitForLibraries() {
        return new Promise((resolve) => {
            const checkLibraries = () => {
                if (window.tf && window.use && window.React && window.ReactDOM) {
                    tf = window.tf; use = window.use; React = window.React; ReactDOM = window.ReactDOM;
                    resolve();
                } else { setTimeout(checkLibraries, 100); }
            };
            checkLibraries();
        });
    }

    window.AI_MODEL_INFO = {
  "success": true,
  "aiPurpose": "ê³ ì–‘ì´, ê°•ì•„ì§€ ì‚¬ì§„ ë¶„ë¥˜",
  "dataType": "image",
  "trainerScriptPath": "/scripts/image_trainer.js",
  "labels": [
    "cat",
    "dog"
  ],
  "imageSize": [
    64,
    64,
    3
  ],
  "feedback": "ì´ë¯¸ì§€ ë¶„ë¥˜ ëª¨ë¸ í•™ìŠµ ì •ë³´ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ì—ì„œ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤.",
  "initialUserData": {
    "image": [
      {
        "description": "Cat photo 1",
        "label": "cat"
      },
      {
        "description": "Cat photo 2",
        "label": "cat"
      },
      {
        "description": "Cat photo 3",
        "label": "cat"
      },
      {
        "description": "Cat photo 4",
        "label": "cat"
      },
      {
        "description": "Cat photo 5",
        "label": "cat"
      },
      {
        "description": "Cat photo 6",
        "label": "cat"
      },
      {
        "description": "Cat photo 7",
        "label": "cat"
      },
      {
        "description": "Cat photo 8",
        "label": "cat"
      },
      {
        "description": "Dog photo 1",
        "label": "dog"
      },
      {
        "description": "Dog photo 2",
        "label": "dog"
      },
      {
        "description": "Dog photo 3",
        "label": "dog"
      },
      {
        "description": "Dog photo 4",
        "label": "dog"
      },
      {
        "description": "Dog photo 5",
        "label": "dog"
      },
      {
        "description": "Dog photo 6",
        "label": "dog"
      },
      {
        "description": "Dog photo 7",
        "label": "dog"
      },
      {
        "description": "Dog photo 8",
        "label": "dog"
      },
      {
        "description": "Cat photo 9",
        "label": "cat"
      },
      {
        "description": "Cat photo 10",
        "label": "cat"
      },
      {
        "description": "Dog photo 9",
        "label": "dog"
      },
      {
        "description": "Dog photo 10",
        "label": "dog"
      }
    ]
  },
  "modelName": "20250828_122558_199",
  "modelArchitecture": "MobileNetV2_transfer",
  "modelFiles": [
    {
      "signedUrl": "https://oneclickai-s3.s3.ap-northeast-2.amazonaws.com/ai-models/20250828_122558_199/model.json",
      "path": "ai-models/20250828_122558_199/model.json"
    },
    {
      "signedUrl": "https://oneclickai-s3.s3.ap-northeast-2.amazonaws.com/ai-models/20250828_122558_199/weights.bin",
      "path": "ai-models/20250828_122558_199/weights.bin"
    }
  ]
};
    window.S3_MODEL_FILES = [
  {
    "signedUrl": "https://oneclickai-s3.s3.ap-northeast-2.amazonaws.com/ai-models/20250828_122558_199/model.json",
    "path": "ai-models/20250828_122558_199/model.json"
  },
  {
    "signedUrl": "https://oneclickai-s3.s3.ap-northeast-2.amazonaws.com/ai-models/20250828_122558_199/weights.bin",
    "path": "ai-models/20250828_122558_199/weights.bin"
  }
];
    window.injectedInitialState = {
        aiPurpose: window.AI_MODEL_INFO.aiPurpose || "ê³ ì–‘ì´, ê°•ì•„ì§€ ì‚¬ì§„ ë¶„ë¥˜",
        dataType: window.AI_MODEL_INFO.dataType,
        loadedModelPath: window.S3_MODEL_FILES.length > 0 ? window.S3_MODEL_FILES[0].signedUrl : null,
        labels: window.AI_MODEL_INFO.labels,
        gptFeedback: window.AI_MODEL_INFO.feedback || "...",
        s3BucketName: "oneclickai-s3"
    };

    async function initializeApp() {
        try {
            await waitForLibraries();
            await tf.ready();
            const { useState, useEffect, useRef } = React;
            
            const loadImage = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            const TextInputComponent = ({ reference, placeholder }) => (React.createElement("div", { className: "mb-4" }, React.createElement("label", { htmlFor: "actual-test-input", className: "block text-gray-700 text-sm font-bold mb-2" }, "í…ŒìŠ¤íŠ¸í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:"), React.createElement("textarea", { id: "actual-test-input", ref: reference, className: "shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline", rows: 5, placeholder: placeholder })));
            const ImageInputComponent = ({ onChange, previewUrl }) => (React.createElement("div", { className: "mb-4" }, React.createElement("label", { htmlFor: "test-image-upload", className: "block text-gray-700 text-sm font-bold mb-2" }, "í…ŒìŠ¤íŠ¸í•  ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”:"), React.createElement("input", { type: "file", id: "test-image-upload", accept: "image/*", onChange: onChange, className: "block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" }), previewUrl && (React.createElement("div", { className: "mt-4" }, React.createElement("img", { src: previewUrl, alt: "Image Preview", className: "max-w-xs h-auto rounded-lg shadow-md" })))));
            const ModelTestSection = ({ modelLoadStatus, renderInputArea, handleTestPrediction, handleClearTestData, classifierModel, featureExtractor, isPredicting, testOutputResult }) => (React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-md" }, React.createElement("h2", { className: "text-xl font-semibold mb-3" }, "ëª¨ë¸ í…ŒìŠ¤íŠ¸"), React.createElement("div", { className: "mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg" }, React.createElement("h3", { className: "font-semibold text-blue-800" }, "ëª¨ë¸ ìƒíƒœ"), React.createElement("p", { id: "model-load-status", className: "text-blue-700" }, modelLoadStatus)), renderInputArea(), React.createElement("div", { className: "flex space-x-2 mb-4" }, React.createElement("button", { id: "test-predict-btn", onClick: handleTestPrediction, disabled: !classifierModel || !featureExtractor || isPredicting, className: "bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:bg-gray-400 disabled:cursor-not-allowed" }, isPredicting ? 'ì˜ˆì¸¡ ì¤‘...' : 'ì˜ˆì¸¡ ì‹¤í–‰'), React.createElement("button", { id: "clear-test-data-btn", onClick: handleClearTestData, className: "bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline" }, "ì…ë ¥ ì´ˆê¸°í™”")), React.createElement("div", { className: "mb-4" }, React.createElement("h3", { className: "text-lg font-semibold" }, "ì˜ˆì¸¡ ê²°ê³¼:"), React.createElement("pre", { id: "test-output-result", className: "mt-2 p-4 bg-gray-100 rounded-md border border-gray-300 whitespace-pre-wrap min-h-[100px]" }, testOutputResult || 'ì´ê³³ì— ì˜ˆì¸¡ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤.'))));
            const GptFeedbackSection = ({ gptFeedback }) => (React.createElement("div", { className: "mt-6 bg-green-50 p-6 rounded-lg shadow-md border border-green-200" }, React.createElement("h3", { className: "text-lg font-semibold text-green-800" }, "GPT í”¼ë“œë°±:"), React.createElement("p", { className: "mt-2 text-green-700" }, gptFeedback)));
            const TrainedLabelListSection = ({ labels }) => (Array.isArray(labels) && labels.length > 0 && (React.createElement("div", { className: "mt-6 bg-gray-50 p-6 rounded-lg shadow-md" }, React.createElement("h3", { className: "text-lg font-semibold" }, "í•™ìŠµëœ ë¼ë²¨ ëª©ë¡:"), React.createElement("ul", { className: "list-disc list-inside mt-2 space-y-1" }, labels.map((label, index) => React.createElement("li", { key: index }, label))))));

            function App() {
                const { dataType, loadedModelPath, labels, s3BucketName, gptFeedback } = window.injectedInitialState;
                const [classifierModel, setClassifierModel] = useState(null);
                const [featureExtractor, setFeatureExtractor] = useState(null);
                const [modelLoadStatus, setModelLoadStatus] = useState('ëª¨ë¸ ë¡œë“œ ëŒ€ê¸° ì¤‘...');
                const [testImageFile, setTestImageFile] = useState(null);
                const [testImagePreviewUrl, setTestImagePreviewUrl] = useState(null);
                const [testOutputResult, setTestOutputResult] = useState('');
                const [isPredicting, setIsPredicting] = useState(false);
                const actualTestInputRef = useRef(null);
                
                useEffect(() => {
                    let isMounted = true;
                    const loadAllModels = async () => {
                        if (!loadedModelPath || !s3BucketName) { setModelLoadStatus('ì˜¤ë¥˜: ëª¨ë¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.'); return; }
                        try {
                            setModelLoadStatus('AI ëª¨ë¸ ë¡œë”© ì¤‘...');
                            const modelJsonFile = window.S3_MODEL_FILES.find(f => f.path.endsWith('.json'));
                            if (!modelJsonFile) throw new Error("ëª¨ë¸ JSON íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                            
                            const loadedClassifier = await tf.loadLayersModel(modelJsonFile.signedUrl); // URLì„ ì§ì ‘ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •
                            if (!isMounted) { loadedClassifier.dispose(); return; }
                            setClassifierModel(loadedClassifier);
                            let loadedFeatureExtractor;
                            if (dataType === 'text') {
                                loadedFeatureExtractor = await use.load();
                            } else if (dataType === 'image') {
                                const MOBILENET_URL = 'https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v2_100_224/feature_vector/3/default/1';
                                loadedFeatureExtractor = await window.tf.loadGraphModel(MOBILENET_URL, { fromTFHub: true }); // tf ëŒ€ì‹  window.tf ì‚¬ìš©
                            }
                            if (!isMounted) { if (loadedFeatureExtractor?.dispose) loadedFeatureExtractor.dispose(); return; }
                            setFeatureExtractor(loadedFeatureExtractor);
                            setModelLoadStatus('ğŸ‰ ëª¨ë“  ëª¨ë¸ ë¡œë“œ ì™„ë£Œ! ì˜ˆì¸¡ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                        } catch (e) {
                            console.error('ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:', e);
                            if (isMounted) setModelLoadStatus("ì˜¤ë¥˜: ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨. (" + e.message + ")");
                        }
                    };
                    loadAllModels();
                    return () => {
                        isMounted = false;
                        if (classifierModel) classifierModel.dispose();
                        if (featureExtractor && typeof featureExtractor.dispose === 'function') {
                            featureExtractor.dispose();
                        }
                    };
                }, []);
                
                    const handleTestImageUpload = (event) => { const file = event.target.files[0]; if (file) { setTestImageFile(file); setTestImagePreviewUrl(URL.createObjectURL(file)); } else { clearTestImage(); } };
                    const clearTestImage = () => { if (testImagePreviewUrl) URL.revokeObjectURL(testImagePreviewUrl); setTestImageFile(null); setTestImagePreviewUrl(null); const uploader = window._currentShadowRoot.getElementById('test-image-upload'); if (uploader) uploader.value = ''; };
                    const handleClearTestData = () => { if (dataType === 'text' && actualTestInputRef.current) { actualTestInputRef.current.value = ''; } if (dataType === 'image') { clearTestImage(); } setTestOutputResult(''); };
                    const handleTestPrediction = async () => { if (!classifierModel || !featureExtractor) { setTestOutputResult('ì˜¤ë¥˜: ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'); return; } let inputData; if (dataType === 'text') { const textInput = actualTestInputRef.current ? actualTestInputRef.current.value : ''; if (!textInput.trim()) { setTestOutputResult('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'); return; } inputData = { text: textInput }; } else if (dataType === 'image') { if (!testImageFile) { setTestOutputResult('ì´ë¯¸ì§€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.'); return; } inputData = { file: testImageFile }; } setIsPredicting(true); setTestOutputResult('ì˜ˆì¸¡ ì¤‘...'); try { let resultText = ''; if (dataType === 'text') { const texts = inputData.text.split(',').map(t => t.trim()).filter(Boolean); if (texts.length === 0) throw new Error("ì…ë ¥ í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤."); const embeddings = await featureExtractor.embed(texts); const prediction = classifierModel.predict(embeddings); const predictionData = await prediction.array(); tf.dispose([embeddings, prediction]); resultText = texts.map((text, i) => { const probabilities = predictionData[i]; const topResultIndex = probabilities.indexOf(Math.max(...probabilities)); const topLabel = labels[topResultIndex] || 'ì•Œ ìˆ˜ ì—†ìŒ'; const topProbability = (probabilities[topResultIndex] * 100).toFixed(2); return `"${text}": ${topLabel} (${topProbability}%)`; }).join('\n'); } else if (dataType === 'image') { const img = await loadImage(inputData.file); const result = tf.tidy(() => { const MODEL_IMAGE_SIZE = 224; let imageTensor = tf.browser.fromPixels(img).resizeNearestNeighbor([MODEL_IMAGE_SIZE, MODEL_IMAGE_SIZE]).toFloat().div(tf.scalar(255)); if (imageTensor.shape[2] === 4) imageTensor = imageTensor.slice([0, 0, 0], [MODEL_IMAGE_SIZE, MODEL_IMAGE_SIZE, 3]); const batchedImage = imageTensor.expandDims(0); const embedding = featureExtractor.predict(batchedImage); return classifierModel.predict(embedding).dataSync(); }); const probabilities = Array.from(result); const predictedClassIndex = probabilities.indexOf(Math.max(...probabilities)); const predictionLabel = labels[predictedClassIndex] || 'ì•Œ ìˆ˜ ì—†ìŒ'; const predictionProb = (probabilities[predictedClassIndex] * 100).toFixed(2); resultText = `ì˜ˆì¸¡ ê²°ê³¼: ${predictionLabel} (${predictionProb}%)`; const probMap = labels.map((label, i) => `  "${label}": ${(probabilities[i] * 100).toFixed(2)}%`).join(',\n'); resultText += `\n\n- ì „ì²´ í™•ë¥ ë¶„í¬ -\n{\n${probMap}\n}`; } setTestOutputResult(resultText); } catch (e) { console.error('ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', e); setTestOutputResult('ì˜¤ë¥˜: ì˜ˆì¸¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ' + e.message); } finally { setIsPredicting(false); } };
                    const renderInputArea = () => { switch (dataType) { case 'text': return React.createElement(TextInputComponent, { reference: actualTestInputRef, placeholder: "í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”." }); case 'image': return React.createElement(ImageInputComponent, { onChange: handleTestImageUpload, previewUrl: testImagePreviewUrl }); default: return React.createElement("p", { className: "text-red-500" }, "ì§€ì›ë˜ì§€ ì•ŠëŠ” ë°ì´í„° íƒ€ì…ì…ë‹ˆë‹¤: " + dataType); } };
    
                    return (
                        React.createElement(React.Fragment, null,
                            React.createElement(ModelTestSection, {
                                modelLoadStatus, renderInputArea, handleTestPrediction, handleClearTestData,
                                classifierModel, featureExtractor, isPredicting, testOutputResult
                            }),
                            React.createElement(GptFeedbackSection, { gptFeedback }),
                            React.createElement(TrainedLabelListSection, { labels })
                        )
                    );
                }
    
                // â—ï¸ [í•µì‹¬ ìˆ˜ì •] Shadow DOM ëŒ€ì‹  iframeì˜ í‘œì¤€ documentë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                const rootElement = document.getElementById('model-test-section');
                if (rootElement) {
                    const root = ReactDOM.createRoot(rootElement);
                    root.render(React.createElement(App, null));
                } else {
                    console.error("'model-test-section' element not found in the document.");
                }
            } catch (error) {
                console.error('ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                window._currentShadowRoot.getElementById('model-test-section').innerHTML = 
                    '<div class="p-4 bg-red-100 border border-red-400 text-red-700 rounded">' +
                    'ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message + '</div>';
            }
        }
    
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        
        }
    </script>
    </body>
    </html>